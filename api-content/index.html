{"posts":[{"title":"Java 基础篇","content":"让程序性能优异的并发利器 线程池 创建参数对工作机制对影响 线程池构造函数： public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler) 参数含义： corePoolSize 线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize； 如果当前线程数=corePoolSize，继续提交的任务会被保存到阻塞队列中，等待被执行； 如果执行了线程池的 prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。 maximumPoolSize 线程池允许的最大线程数。 如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于 maximumPoolSize; keepAliveTime 非核心线程空闲时的存活时间，当没有任务执行时，非核心线程继续存活的时间。 默认情况下，该参数只在线程数大于corePoolSize时才有用。 TimeUnit keepAliveTIme的时间单位。 workQueue workQueue必须是BlockingQueue阻塞队列。 当线程池中的线程数超过他的corePoolSize的时候，线程会进入阻塞队列进行阻塞等待。通过workQueue，线程池实现了阻塞功能。 workQueue 用于保持等待执行任务的的任务阻塞队列，尽量使用有界队列，因为无界队列会对线程池有影响： 1、当线程池中的线程数达到corePoolSize后，新任务将在无界队列中等待，因为线程池中的线程数不会超过corePoolSize； 2、使用无界队列时，maximumPoolSize和keepAliveTime将是无效参数 3、使用无界queue可能会耗尽系统资源，有界队列则有助于防止资源耗尽，同时即使使用有界队列，也要控制队列的大小在一个合适的范围。 所以一般使用 ArrayBlockingQueue，LinkedBlockingQueue，SynchronousQueue，PriorityBlockingQueue threadFactory 创建线程的工厂。 通过自定义的线程工厂，可以给每个新建的线程设置一个具有识别度的线程名，当然还可以更加自由的对线程做更多的设置，比如设置所有的线程为守护线程。 Exexutors 静态工厂里默认的threadFactory，线程的命名规则是“pool-数字-thread-数字” RejectedExecutionHandler 线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，即当前线程数已经达到最大线程数，如果继续提交任务，必须采取一种策略处理该任务。 线程池提供了4中策略： 1、AbortPolicy：直接抛出异常，默认策略 2、CallerRunsPolicy: 用调用者所在的线程来执行任务 3、DiscardOlderestPolicy： 丢弃阻塞队列中靠最前的任务，并执行当前任务 4、DiscardPolicy: 直接丢弃任务 也可以根据应用场景实现 RejectedExecutionHandler接口，自定义饱和策略，如记录日志活持久化存储不能处理的任务。 合理配置线程池 首先分析任务特性： * 任务的性质：CPU密集型，IO密集型和混合型任务 * 任务的优先级：高，中，低 * 任务的执行时间：长，中，短 * 任务的依赖性：是否依赖其他系统资源，如数据库链接 性质不同的任务可以用不同规模的线程池分开处理 CPU 密集型任务应配置尽可能小的线程，如配置Ncpu+1个线程的线程池。 IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如 2*Ncpu。 混合型的任务，如果可以拆分，将其拆分为一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。 可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。 概述 ConcurrentHashMap 基本概述 ConcurrentHahsMap 是线程安全的Map，1.7 和 1.8 中实现方式不同 1.7 采用分段锁的机制，实现并发的更新操作，底层采用数组+链表的存储结构，包括两个核心静态内部类 Segment 和 HashEntry。 1、segment继承ReentrantLock（重入锁）用来充当锁的角色，每个Segemnt 对象守护每个散列映射表的若干个锁。 2、HashEntry 用来风中映射表的键值对 3、每个桶是由若干个HashEntry 对象链接起来的链表 1.8 采用 Node+CAS+Synchronized 来保证并发安全。取消类Segment，直接用table数组存储键值对；当HashEntry对象组成对链表长度超过 TREEIFY_ THRESHOLD 时，链表转换为红黑树，提升性能。底层变更为数组 + 链表 + 红黑树。 1、重要对常量： private transient volatile int sizeCtl; 当为负数时，-1表示正在初始化，-N表示 N -1 个线程正在进行扩容； 当为 0 时，表示 table 还没有初始化； 当为其他正数时，表示初始化或者下一洗进行扩容的大小。 2、 数据结构： Node时存储结构的基本单元，实现了Map中的Entry接口，用于存储数据； TreeNode继承Node，但是数据结构换成来二叉树结构，是红黑树的存储结构，用于红黑树中存储数据。 3、存储对象时（put（） 方法） 1、如果没有初始化，就调用initTable（）方法来进行初始化； 2、如果没有 hash 冲突就直接 CAS 无锁插入； 3、如果需要扩容，就先进行扩容； 4、如果哦存在hash冲突，就枷锁来保证线程安全，两种情况：一种时链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入； 5、如果该链表的数量大雨阈值8，就要先转换成红黑树的结构 6、如果添加成功就调用 addCount（）方法统计size，并坚持是否需要扩容。 4、扩容方法 transfer（） 默认容量为16，扩容是，容量变为原来的两倍 helpTransfer（）： 调用多个工作线程一起帮助进行扩容，效率更高 5、获取对象时（get（）方法） 1、计算hash值，定位到该table索引位置，如果是首节点符合就返回； 2、如果遇到扩容时，会标记正在扩容结点 ForwardingNode.find() 方法，查找该结点，匹配就返回； 3、以上都不符合的话，就往下遍历结点，匹配就返回，否则最后就返回 null 为什么hashmap1.8 不直接使用红黑树而还要保留链表 因为插入时红黑树需要进行左旋，右旋操作，而单链表不需要，在数量较少时，红黑树并没有表现出比链表更好的查询效率，而且在占用空间上，红黑树的节点比链表的节点更大，时链表的两倍。 为什么大于8个的时候才转换红黑树 1、 按照JDK源码的解释： TreeNodes占用空间是普通Nodes的两倍，所以只有当bin包含足够多的节点时才会转成TreeNodes，而是否足够多就是由 TREEIFY_THRESHOLD的值决定的。当bin中节点数变少时，又会转成普通的bin。TREEIFY_THRESHOLD的值是这个空间和时间的权衡。 当hashCode离散性很好的时候，树形bin用到的概率非常小，因为数据均匀分布在每个bin中，几乎不会有bin中链表长度会达到阈值。 但是在随机hahsCode下，离散性可能会变差，然而JDK又不能阻止用户实现这种不好的hash算法，因此就可能导致不均匀的数据分布。 不过理想情况下随机 hashCode 算法下所以bin中节点的分布频率会遵循泊松分布，一个bin中链表长度达到8个元素的概率为 0.00000006，几乎是不可能时间。所以，之所以选择8，不是拍拍屁股决定的，而是根据概率统计决定的。 2、网上的说法： 红黑树的平均查找长度是 log(n), 如果长度为8，平均查找长度为 log(8)=3，链表的平均查找长度为n/2，当长度为8是，平均查找长度为8/2=4，这才有转换成树的必要；链表长度如果小于等于6，6/2=3，而log(6)=2.6, 虽然速度也很快，但是转化为树结构和生成树的时间并不会太短。 概述volatile volatile 关键字的主要作用： 多线程主要围绕可见性和原子性两个特性而展开，使用volatile 关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据。但是volatile不能保证操作的原子性，对任意单个volatile变量的读/写具有原子性，但类似++这种复合操作不具有原子性。 代码底层在执行时为了获取更好的性能会对指令进行重排序，多线程下可能会出行一些意想不到的问题。使用volatile则会禁止重排序，但是会降低代码的执行效率。 同时在内存语义上，当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存，当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。 在java中，对与volatile修饰的变量，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序问题、强制刷新和读取。 在具体实现上，volatile关键字修饰的变量会存在一个“lock：”的前缀。它不是一种内存屏障，但是它能完成类似内存屏障的功能，lock会对CPU总线和高速缓存加锁，可以理解为CPU指令级的一种锁。 同时该指令会将当前处理器缓存行的数据直接写回到系统内存中，且这个写回内存的操作会使在其他CPU里缓存了该地址的数据无效。 概述AQS AQS是用来构建锁或者其他同步组件的基础框架，比如ReentrantLock、ReentrantReadWriteLock 和 CountDownLatch 就是基于AQS实现的。 它使用了一个int成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。踏实CLH队列锁的一种变体实现。它可以实现2种同步方式：独占式，共享式。 AQS的主要使用方式式继承，子类通过继承AQS并实现它的抽象方法来管理同步状态，同步器的设计基于模版方法模式，所以如果要实现我们自己的同步工具类就需要覆盖其中几个可以重写的方法：tryAcquire，tryReleaseShared 等。 这样设计的目的是同步组件（比如锁）是面向使用者的，它定义来使用者于同步组件交互的接口（比如可以允许两个线程并行访问），隐藏来实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。这样可以很好的隔离使用者和实现者所需要关注的领域。 在内部，AQS维护一个共享资源state，通过内置的FIFO来完成获取资源线程的排队工作。该队列由一个一个的Node节点组成，每个Node节点维护一个prev引用和next引用，分别指向自己的前驱和后继节点，构成一个双端双向链表。 同时与Condition相关的等待队列，节点类型也是Node，构成一个单向链表。 synchronized 的实现原理 synchronized 在JVM里的实现都是基于进入和退出的Monitor对象来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成对的 MonitorEnter 和 MonitorExit 指令来实现。 对同步块，MonitorEnter指令插入在同步代码块的开始位置，当代码执行到该指令时，将会尝试获取该对象Monitor到所有权，即尝试获得该对象的锁，而monitorExit指令则插入在方法结束处和异常处，JVM保证每个MonitorEnter必须有对应的MonitorExit。 对同步方法，从同步方法反编译对结果来看，方法对同步并没有通过指令monitorEnter和monitoerExit来实现，相对于普通方法，其常量池中多来 ACC_SYNCHRONIZED 标示符。 JVM就是根据该标示符来实现方法的同步的： 当方法被调用时，调用指令将会坚持方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后在释放monitor。在方法执行期间，其他任何线程都无法在获得同一个monitor对象。 synchronized使用的锁是存放在Java对象头里面，具体位置是对象头里面的MarkWord，MarkWord 里默认数据是存储对象的HashCode 等信息，但是会随着对象的运行改变而发生变化，不同的锁状态对应着不同的记录存储方式。在具体优化上，从1.6开始引入了偏向锁、自旋锁等机制提升性能。 什么是CAS操作，缺点是什么？ CAS的基本思路是：如果这个地址上的值和期望的值相等，则给其赋予新值，否则不做任何事，但是要返回原值是多少。每个CAS操作过程都包含三个运算符：一个内存地址V, 一个期望的值A 和 一个新值B，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则不做任何操作。 CAS 缺点： ABA问题： 一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，最终又变回A，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但可能存在潜在但问题。从Java1.5开始，JDK的atomic包里提供了一个类的AtomicStampedReference来解决ABA问题。 循环时间长，开销大： 对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。 只能保证一个共享变量的原子操作： 当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时间就可以用锁。 ","link":"http://blog.801314.top/post/mianshi-java-jichu/"},{"title":"《大宅门》里白景琦的两封遗书","content":"七爷的第一封遗书 &quot;我，白景琦，生于光绪六年，自幼顽劣，不服管教，闹私塾，打兄弟，毁老师，无恶不作。长大成人更肆无忌惮，与仇家女私订终身，杀德国兵，交日本朋友，终被慈母大人赶出家门；从此闯荡江湖，独创家业。&quot; &quot;一泡屎骗了两千银子，收了沿河二十八坊，独创'泷胶'、'保生'、'九宝'、'七秀'三十二张秘方，济世救民，兴家旺族；为九红，我坐过督军的大牢，为槐花，坐过民国的监狱，为香秀，得罪过全家老少，越不叫我干什么，我偏要干什么！除了我妈，我没向谁低过头，没向谁弯过腰！&quot; &quot;如今，日本鬼子打到了咱们家门口，逼死了三老太爷，我立誓，宁死不当亡国奴！我死以后，本族老少如有与日本鬼子通同一气者，人人可骂之！我死以后，如有与日本鬼子通同一气者，人人可诛之！我死以后，……如有与日本鬼子通同一气者，照着我这口刀说话！&quot; 立遗嘱人，白景琦！ 七爷的第二封遗书 “我,白景琦，生于光绪六年，今年86了。一只烤鸭是吃不动了，酒还能喝半坛子。神龟虽寿，犹有竟时。为昭示子孙后代立此遗嘱： 景琦一生，无愧于祖先无愧于家人。自日寇侵华以来，屡遭迫害，身陷囹圄，保住了秘方。为抗日尽了微薄之力，惟气节二字，不曾丝毫动摇。 光复之日，又遭诬陷，九死一生，虽百折而不屈。回首来路，刀光剑影，血迹斑斑，幸得解放，迎来盛世。 景琦未敢稍稍怠慢。举合营之首，献秘方于先，赴总理之茶话会，参政协之学习班，亦步亦趋，不甘落同仁之后。无奈子孙不孝，为夺财产，父子相争，夫妻反目，兄弟结仇，姊妹相残，景琦已无回天之力，更不忍见后代子孙专以争夺财产为能事，不思进取。 自今日起，全部国宝珍玩尽献与故宫博物院。自今日起，放弃全部股息，以期子孙自食其力，报效国家。我死以后，如有子孙念及先祖之苦心，烧一陌纸钱，焚一柱清香。就说你已自立，你已成才，景琦死亦瞑目。 立遗嘱人:白景琦 ","link":"http://blog.801314.top/post/dazhaimen/"},{"title":"《闻香识女人》经典台词","content":"1、 如今我走到人生十字路口，我知道哪条路是对的，毫无例外，我就知道，但我从不走，为什么？因为他妈的太苦了！ 2、问题不是哪条路是对的，问题是，你敢不敢走？人即使身残，也因保持灵魂的完整，因为灵魂没有假肢。 3、 我想有个女人拥住我，我埋在她的秀发里闻香，而第二天醒来，她还在我身边。 4、我知道哪条路都能通向正道，但是我从不尝试，为什么？因为，走正道太难。 5、 探戈里无所谓错步的，不像人生。 6、有时决定了要走，却总是徘徊留恋。有时决定留下，眼神却总望着远方的山水。没关系，唱首歌，走走停停地看看风景。一条路始终有个尽头。 7、如果一个人是坏人，并不是因为他本性有多恶，只是因为他的生命中积累了太多的的坏。是的，世界上没有坏人，只有在痛苦中的人。 8、世界就是如此，东窗事发的时候有人走，有人留。 9、逃避责任的倾向谁都有，但正因如此，世界才呼唤“正直”和“勇气”。 10、如果你跳错了也没关系，接着跳下去。 11、舞跳错了还可以继续，但生活不一样。 12、没有什么比精神残废更可怕，因为没有义肢可以装。一个女人的坚强精神，比她的外在更可贵，因为即便她独自一人，也能光芒四射。 13、如果一个人是坏人，并不是因为他本性有多恶，只是因为他的生命中积累了太多坏的东西。世界上没有坏人，只有在痛苦中的人。 14、没有什么比残缺的灵魂更可怕，而且那是任何东西都无法填补的。 ","link":"http://blog.801314.top/post/lesslesswen-xiang-shi-nu-ren-greatergreater-jing-dian-tai-ci/"},{"title":"资深架构师成长路线 -- 分布式方案及团队协作工具","content":"1、分布式事务解决方案 事务与锁 标准分布式事务 两阶段提交 BASE理论与柔性事务 TCC方案 补偿性方案 异步确保型与最大努力型 2、单点登录方案 单点登录的问题背景 页面跨域问题 Session跨域共享方案 Session 的扩展 3、分布式任务调度方案 Quartz调度的用法 Elastic-Job示例 分布式调度的疑难点 Quartz集群定制化分布式调度 4、Maven 安装与配置 使用入门 坐标和依赖 聚合与继承 生命周期与插件 仓库及版本管理 私服-Nexus 手写Maven插件实战 5、Jenkins Jenkins远程测试 Jenkins持续部署 Jenkins自动部署 Jenkins分布式构建 Jenkins管理 Jenkinis安装 6、git 与svn对比 基本运作流程 Git常用操作及问题处理 ","link":"http://blog.801314.top/post/jiagoushi-gongju/"},{"title":"资深架构师成长路线 -- 分布式扩展到微服务架构","content":"1、从RPC开始 服务注册与发布 动态代理 序列化与反射 手写RPC框架实战 2、DUBBO 10分钟学会Dubbo使用 项目之间的依赖划分实战 传统项目拆解分布式实战 Dubbo api 扩展实战 Dubbo 源码深度解读 Dubbo 面试题指南 3、Spriing Boot Spring Boot 快速入门 核心组件分析 性能优化 jta+atomikos分布式事务 SpringBoot核心源码解读 手写SpringBoot实战 SpringBoot面试汇总 4、Spring Cloud Netflix Zuul路由网关详解及源码探析 Ribbon客户端负载均衡原理与算法详解 Feign 声明式服务调用方式实现 Hystrix服务熔断及服务降级实战 Eureka注册中心构件分析 Config配置服务中心与svn，git快速集成 BUS消息总线技术 Sleuth调用链路跟踪 Stream 消息驱动的微服务 SpringCloud 面试题目汇总 5、Spring Cloud Alibaba Nacos Nacos概述 Nacos-Discovery服务发现 配置中心Nacos-Config Sky Walking 链路跟踪概述 客户端/服务端实战 Assembly Plugin Sentinel （限流） Sentinel 熔断器特性 Sentinel 回退机制 Feigb集成Sentinel Sentinel-Dashboard Seata（分布式事务） 角色中的角色 Seata Server Seata请求逻辑 实战分布式事务 6、docker 5分钟搞定Docker安装与使用 Docker的基本操作 Docker File快速进阶 Docker网络与存储那些事 DockerCompose高阶用法 微服务与Docker集成实现动态扩容实战 7、kubernets Kubernetes简介及安装配置 Kubernetes核心原理 Kubernetes集群管理方案实战 8、Service Mesh 10分钟快速入门与介绍 核心组件解析 如何利用Helm部署Istio 快速解析Istio的常用功能 Mixer适配器的应用 http流量管理实战 Istio的安全加固实战 ","link":"http://blog.801314.top/post/jiagoushi-fenbushi/"},{"title":"资深架构师成长路线 -- 高效存储让项目性能起飞","content":"1、Redis 5分钟搞定Linux下Redis安装 String，List，Hash，Set，Zset类型使用场景 时间轴、队列应用场景设计实战 购物车开发与设计实战 Redis与Lua模拟抢红包实战 网站投票设计与开发实战 Lua+Redis联合开发指南 Redis慢操作优化 Redis哨兵机制及底层机制分析 10分钟搭建Redis高可用集群实战 动态扩容，缩减集群节点实战 Redis 常见面试题汇总 2、缓存解决方案实战 15分钟掌握项目中SpringCache的用法 缓存的一致性策略（跟下及失效处理机制） 缓存雪崩解决方案 缓存穿透方案 3、mongoDB Mongodb使用场景分析 20分钟完整增删改查 MongoDB开发时你应该注意的事项 安全设置及存储引擎分析指南 性能调优与索引实战 复制架构解析实战 MongoDB分区实战 4、MySql高可用 Mysql主从复制、读写分离高可用方案实战 Mysql+keepalived实现双主高可用方案实战 Mysql实现分库分表高性能解决方案实战 5、Mycat Mycat简介及用途 基于Mycat实现Mysql读写分离实战 基于Mycat实现数据库切分实战 全局表、ER表、分片机制分析 6、Sharding-Sphere Sharding-JDBC 引擎原理与数据分片剖析 读写分离 编排治理 数据脱敏 Sharding-Proxy 7、FastDFS 文件存储实战 文件同步实战 文件查询实战 分布式部署实战 ","link":"http://blog.801314.top/post/jiagoushi-gaoxiao/"},{"title":"资深架构师成长路线 -- 性能直线提升架构技术","content":"1、分布式架构思维 大型互联网架构严谨过程 架构师应具备的分布式知识 主流分布式架构设计详解 2、Zookeeper 5分钟搞定Zookeeper安装及指令解析 原始客户端、zkclient、curotor快速开发实战 zookeeper应用实战 配置中心 命名服务 集群选举实战 分布式锁实战 zookeeper底层协议解读 2p, 3p cap base paxos zab zookeeper 面试资料整理 3、nginx 5分钟将你的项目实现nginx分流 nginx安装及基本使用 nginx进程模型及配置详解 location规则及rewrite解析 动静分离实战 反向代理实战 跨域配置实战 缓存配置及gzip配置实战 https安全认证实战 LVS高可用实战 nginx那些面试题汇总 4、消息中间件概述 消息中间件和RPC的区别 消息中间件使用场景介绍 ActiveMQ，RabbitMQ，RocketMQ，Kafka对比 消息中间件的编年史 5、ActiveMQ 3分钟快速安装ActiveMQ JMS规范解读 原生ActiveMQ的API编程 ActiveMQ高级特性和用法 限时订单实战 用户注册的异步处理实战 企业高可用集群部署实战 6、RabbitMQ Linux下安装与配置 消息发布与消费权衡 消息的拒绝怎么解决 控制队列与消息属性 与Spring集成完成应用结偶实战 集群化与镜像队列实战 RabbitMQ常见面试题汇总 7、RocketMQ RocketMQ快速安装与配置 消息发送与消费流程解读 RocketMQ消息存储，消息过滤及事务消息 RocketMQ高可用实战 整合Spring完成用户注册的异步处理实战 整合Spring完成限时订单实战 RocketMQ面试题汇集 8、Kafka Kafka快速安装部署 开启Kafka的集群模式 Kafka的生产者和消费者 Kafka高级特性解读 Kafka处理请求的内部机制剖析 整合Spring完成削峰填谷实战 Kafka面试题汇集 9、elastic ELK ElasticSearch ES原理 ES搜素 索引&amp;映射 分布式CRUD 索引管理 分片 搜索优化 logstash 安装和运行 配置 kibana 安装和运行 配置 ELK常见面试题汇集 ","link":"http://blog.801314.top/post/jiagoushi3/"},{"title":"资深架构师成长路线 -- 设计思想解读开源框架","content":"1、六大原则 单一职责原则 开闭原则 里氏替换原则 依赖倒置原则 接口隔离原则 迪米特法则 2、结构型模式 桥接模式 适配器模式 装饰器模式 代理模式 组合模式 3、创建型模式 建造者模式 单例模式 抽象工厂模式 工厂方法模式 静态工厂模式 4、行为型模式 模版方法模式 策略模式 观察者模式 责任链模式 命令模式 访问者模式 5、Spring 5源码解读 5分钟快速理解Spring核心流程 熟练掌握Spring工作常用注解及陷阱 后置处理器源码解读 BeanFactoryPostProcessor BeanDefinetionRegistry IOC容器源码解读 BeanFactory初始化 各类BeanPostProcessors注册执行 MessageSoource资源国际化初始化 事件派发器、监听器初始化 Bean准备创建工作 完成容器创建 AOP源码解读 AOP核心类的注册及执行时机分析 AOP代理创建原理及源码剖析 AOP核心功能之拦截器链解读 方法压栈及链式调用原则解读 声明式事务源码解读 Spring源码面试题汇总 6、SpringMVC 框架源码解读 Servlet3.0 ServletContainerInitializer容器初始化 ServletRegistration 注册 FilterRegistration过滤器 ServletContext 性能实战 基于Servlet3.0 异步 Callable异步 DeferredResult异步 手写SpringMVC实战 7、Mybatis框架源码解读 5分钟掌握MyBatis的配置使用 动态SQL、缓存及关联查询深入解析 10分钟掌握MyBatis与Spring的集成实战 Mybatis插件开发及源码分析实战 分页插件使用与源码分析 多级关联实战 手写MyBatis框架实战 Mybatis常见面试题汇集 ","link":"http://blog.801314.top/post/jiagoushi1/"},{"title":"资深架构师成长路线 -- 架构师筑基必备技能","content":"1、并发编程进阶 线程共享和写作文 CPU核心数，线程数，时间片轮转机制解读 synchronized，volatile，ThreadLocal 如何实现线程共享 wait，notify/nofityAll，join 方法如何实现线程间协作 并发工具类实战 Fork/Join 分而治之原理及实战 CountDownLatch，CyclicBarrier应用场景和实战 Callable，Future和Future Task源码解读及应用实战 Semaphore，Exchange应用场景和实战 站在巨人肩上操作CAS CAS的原理 CAS带来的ABA问题 原子操作类的正确使用实战 阿里面试常问的显式锁和AQS 深入剖析显示锁Lock底层实现机制 AbstractQueuedSynchronizer实现及源码分析 AQS使用方式及其设计模式 ReentrantLock的底层源码及应用实战 并发容器源码解析及应用实战 ConcurrentHashMap 源码解读及应用实战 ConncurrentHashMap 在JDK1.7，JDK1.8版本对比 ConcurrentSkipListMap，ConcurrentLinkedQueue 源码解读 仅会用线程池是不够的 线程池底层实现分析 手写线程池实战 Executor框架解读实战 架构师应该知道的并发安全解决方案 性能优化实战 深入分析JMM（Java 内存模型） 并发任务执行框架解读 30分钟搞定应用性能优化实战 并发编程面试题目汇集 2、JVM性能深度调优 15种方式编写高效优雅Java程序实战 Java内存区域深入剖析 程序计数器，栈，堆及方法区等 JDK1.6，JDK1.7, JDK1.8 内存区域的变化 站在线程角度来看堆和栈 虚拟机中的对象深度剖析 堆参数设置和内存溢出实战 垃圾回收的内存分配策略 对象存活及强，弱等各种引用辨析 快速解读GC算法之标记-清除、复制及标记-整理算法 正确姿势解读GC日志 快速搞定MAT工具，解读DUMP文件 抽丝剥茧解决内存泄露和内存溢出 你必须知道的JVM执行子系统 类加载机制原理剖析 JVM栈帧及方法调用详解 基于栈等字节码解释执行引擎解读 JVM的类加载机制及执行引擎原理 JVM性能优化实战 常用等性能优化手段分析 GC调用实战 JVM调优实战 JVM 面试锦囊妙计 3、网络编程与高效IO http/tcp/udp网络协议原理透析 原始JDK网络编程 BIO编程 NIO 编程 Netty应用快速入门 Netty粘包/半包文问题解决实战 Netty进阶和实战 服务器推送技术实战 WebSocket通信实战 手写通信框架实战 Netty源码深入分析 Netty常被问到的那些面试题汇集 4、深入Tomcat底层 10分钟熟悉你常用却不知道的Tomcat体系架构 你必须得知道的Tomcat容器及运行机制 Tomcat类加载机制分析 Tomcat 核心组件源码解读 Tomcat高级进阶 手写嵌入式Tomcat实战 Tomcat 优化实战 Tomcat面试题整理 5、Mysql深度优化 Mysql存储引擎选型及注意事项 解读Mysql的共享锁及排他锁 Mysql事务及隔离性级别 30 分钟深入展望执行计划 解读Btree与B+ tree索引 Sql慢查询配置及分析 Sql优化策略及实战 Mysql面试题汇总 6、架构基础必备Linux Linux 安装指南 Linux 基础明亮 用户与用户组系列操作 文件与权限系列操作 架构师应该掌握的shell脚本基础 ","link":"http://blog.801314.top/post/jiagoushi/"},{"title":"《教父》中老教父 维托·唐·柯里昂的经典名言","content":"分享一些《教父》里很精辟地诠释了社会人生的台词： 1、但凡男女之间的那点“意思”，常常是从“不好意思”开始，到“真没意思”结束。 2、不要憎恨你的敌人，那会影响你的判断力。 3、在这个世界上，常常出现这样的情况：最微不足道的人，如果他时刻留意的话，总有机会向那些不可一世的人报仇雪恨。 4、不要轻易说出你的理想，不给别人嘲笑你的机会。 5、除了朋友低估你的优点，世上最大的天然优势就是敌人高估你的缺陷。 6、你有花时间和你的家人在一起吗? 我当然有. 很好!不照顾家人的男人,根本算不上是个男人。 7、永远不要动怒，绝不要威胁，要讲道理。 8、最好的威胁是不采取行动，一旦采取行动却没收到效果，人们就不再怕威胁了。 9、我用了一生的时间，就学会了两个字：小心。 10、伟大的人不是生下来就伟大的，而是在成长过程中显示其伟大的。 11、在一秒钟内看到本质的人和花半辈子也看不清一件事本质的人,自然是不一样的命运。 12、你做出了这个决定，这是你的代价。 13、没有边界的心软，只会让对方得寸进尺；毫无原则的仁慈，只会让对方为所欲为。 14、要宽恕，要遗忘。生命本来就充满了不幸。 15、迈克?柯里昂破天荒地第一次悟出一个道理，为什么像他父亲那样的人，甘愿当盗窃犯和谋杀犯而不愿意当合法社会的守法公民？贫穷，恐惧，屈辱，这些东西太可怕了，对任何一个有骨气的人。 16、社会上常常会有突如其来的侮辱，那是必须忍受的。 17、巨大财富的背后，都隐藏着罪恶。 18、人可以不断犯错，但绝不能犯要命的错。 19、离你的朋友近些，但离你的敌人要更近，这样你才能更了解他。 20、人之常情，这世上最难处的就是人了。得罪一个人有很多原因，拂了对方一片好心，也是一种得罪。 21、不要让外人知道家族内部的不同意见。 22、第一个帮你敌人说话的兄弟是叛徒。 23、如果一个人很慷慨，那他就必须把自己的慷慨表现得充满感情。 24、永远不要让别人知道你的真实想法。 25、不要说不可能，没有什么不可能。 26、痛苦不像死亡那样无可挽回。 27、和许多天才商人一样，他知道自由竞争是浪费的，垄断才有效率。所以，他的目标就是追求这有效的垄断。 28、以猛虎之形，以蔷薇之声。 29、我伤了感情了，但是我这个人并不把自己的友谊强加于那些不重视友谊的人——那些认为我无足轻重的人。 ","link":"http://blog.801314.top/post/lesslessjiao-fu-greatergreater-zhong-lao-jiao-fu-wei-tuo-tang-ke-li-ang-de-jing-dian-ming-yan/"},{"title":"世间所有的相遇，都是久别重逢","content":"欢迎你来到我的博客❤️ 很喜欢《一代宗师》电影里的一句台词： 世间所有的相遇，都是久别重逢 能来到这里，说明你我有缘💐 如果通过我的文章，你喜欢和我结交的话，欢迎联系我（联系方式在主页--&gt; 关于我中） 没事故事没有酒😂 只有闲谈与白话🤣 ","link":"http://blog.801314.top/post/meet/"},{"title":"First ","content":"整了很久终于搞定了，之后可以作为个人博客发布内容了😀 ","link":"http://blog.801314.top/post/first/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"http://blog.801314.top/post/hello-gridea/"}]}