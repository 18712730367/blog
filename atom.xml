<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://blog.801314.top</id>
    <title>黑白杂色</title>
    <updated>2020-09-02T02:22:37.441Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://blog.801314.top"/>
    <link rel="self" href="http://blog.801314.top/atom.xml"/>
    <subtitle>没有绝对的纯，黑白也是杂色</subtitle>
    <logo>http://blog.801314.top/images/avatar.png</logo>
    <icon>http://blog.801314.top/favicon.ico</icon>
    <rights>All rights reserved 2020, 黑白杂色</rights>
    <entry>
        <title type="html"><![CDATA[linux 脚本]]></title>
        <id>http://blog.801314.top/post/linux-jiao-ben/</id>
        <link href="http://blog.801314.top/post/linux-jiao-ben/">
        </link>
        <updated>2020-06-09T08:43:48.000Z</updated>
        <content type="html"><![CDATA[<h3 id="什么是shell">什么是shell</h3>
<p>shell 是操作系统的一个软件。它包在linux 内核外面，为用户和内核之间的交互提供了一个接口。系统中的命令用shell解释，shell接收系统回应的输出并显示其到屏幕中。</p>
<p>shell 是一个命令语言解释器，它拥有自己内建的shell命令集。</p>
<h3 id="shell-脚本">shell 脚本。</h3>
<p>脚本是一种解释型语言。</p>
<ul>
<li>保存执行动作</li>
<li>判定命令的执行条件</li>
<li>实现动作的批量执行</li>
</ul>
<h4 id="创建脚本">创建脚本</h4>
<pre><code>vim test.sh  用vim编写脚本
#! /bin/bash  脚本使用的解释器，通常用幻数 &quot;#!&quot; 指定
#AUTHOR 脚本作者
#DATE 脚本创作时间
#MAIL 脚本作者联系方式
#VERSION 脚本的版本
</code></pre>
<h4 id="脚本编写">脚本编写</h4>
<pre><code>vim test.sh
内容：
#! /bin/bash
watch -n 1 date
</code></pre>
<h4 id="执行脚本">执行脚本</h4>
<ul>
<li>sh test.sh</li>
<li>chmod +x test.sh 加可执行权限 &amp;&amp; /mnt/test.sh 绝对路径的方式执行</li>
</ul>
<h4 id="脚本调试">脚本调试</h4>
<p>用绝对路径执行后会显示执行脚本调用的解释器和执行结果</p>
<pre><code>#! /bin/bash -x  (注意：-x)
echo hello test

执行：
/mnt/test.sh
输出：
+ echo hello test
hello test
</code></pre>
<h4 id="shell-变量">shell 变量</h4>
<ul>
<li>shell 的变量赋值的时候不用带<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo separator="true">,</mo><mi mathvariant="normal">而</mi><mi mathvariant="normal">使</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">或</mi><mi mathvariant="normal">者</mi><mi mathvariant="normal">输</mi><mi mathvariant="normal">出</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">候</mi><mi mathvariant="normal">需</mi><mi mathvariant="normal">要</mi><mi mathvariant="normal">带</mi></mrow><annotation encoding="application/x-tex">, 而使用或者输出的时候需要带</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3em;vertical-align:-0.19444em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">而</span><span class="mord cjk_fallback">使</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">或</span><span class="mord cjk_fallback">者</span><span class="mord cjk_fallback">输</span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">候</span><span class="mord cjk_fallback">需</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">带</span></span></span></span></li>
<li>加减乘除的时候需要两层小括号，括号外面要有一个$, 括号里面的变量可以不用 $</li>
<li>变量赋值，变量使用的时候不能有空格，否则会被解析为命令<br>
代码示例：</li>
</ul>
<pre><code>#!/bin/bash

a=10
b=20
c=&quot;this is a test&quot;
d=$((a+b))
e=$((a-b))
f=$((a*b))
g=$((a/b))
h=$((a%b))
i=$((a**3))

echo $c
echo &quot;a = &quot;$a          #输出a的值
echo &quot;b = &quot;$b          #输出b的值
echo &quot;a+b = &quot;${d}      #输出a+b的值
echo &quot;a-b = &quot;${e}      #输出a-b的值
echo &quot;a*b = &quot;${f}      #输出a*b的值
echo &quot;a/b = &quot;${g}      #输出a/b的值
echo &quot;a%b = &quot;${h}      #输出a%b的值
echo &quot;a^3 = &quot;${i} 	   #输出a的3次方的值

echo &quot;a+b = &quot;$((a+b))  #输出a+b的值
echo &quot;a-b = &quot;$((a-b))  #输出a-b的值
echo &quot;a*b = &quot;$((a*b))  #输出a*b的值
echo &quot;a/b = &quot;$((a/b))  #输出a/b的值
echo &quot;a%b = &quot;$((a%b))  #输出a%b的值
echo &quot;a^3 = &quot;$((a**3)) #输出a的3次方的值

echo $((a+b*a-b/a+a%b+a**2)) #表达式可以很长
</code></pre>
<ul>
<li>shell 变量表达式</li>
</ul>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>${#string}</td>
<td>计算$string的长度</td>
</tr>
<tr>
<td>${string:position}</td>
<td>从pos开始提取字符串</td>
</tr>
<tr>
<td>${string:position:len}</td>
<td>从pos开始提取长度为len的字符串</td>
</tr>
<tr>
<td>${string#substr}</td>
<td>从开头删除最短匹配子串</td>
</tr>
<tr>
<td>${string##substr}</td>
<td>从开头删除最长匹配子串</td>
</tr>
<tr>
<td>${string%substr}</td>
<td>从结尾删除最短匹配子串</td>
</tr>
<tr>
<td>${string%%substr}</td>
<td>从结尾删除最长匹配子串</td>
</tr>
</tbody>
</table>
<pre><code>#!/bin/bash

str=&quot;a b c d e f g h i j&quot;

echo &quot;the source string is &quot;${str}                         #源字符串
echo &quot;the string length is &quot;${#str}                        #字符串长度
echo &quot;the 6th to last string is &quot;${str:5}                  #截取从第五个后面开始到最后的字符
echo &quot;the 6th to 8th string is &quot;${str:5:2}                 #截取从第五个后面开始的2个字符
echo &quot;after delete shortest string of start is &quot;${str#a*f} #从开头删除a到f的字符
echo &quot;after delete widest string of start is &quot;${str##a*}   #从开头删除a以后的字符
echo &quot;after delete shortest string of end is &quot;${str%f*j}   #从结尾删除f到j的字符
echo &quot;after delete widest string of end is &quot;${str%%*j}     #从结尾删除j前面的所有字符包括j
</code></pre>
<ul>
<li>shell 条件分支结构语句
<ul>
<li>单分支判定语句<pre><code>#!/bin/bash
echo &quot;Please input a filename&quot;
read filename
if [ -f $filename ];then
echo &quot;this file is a ordinary file.&quot;
fi
</code></pre>
</li>
<li>双分支判定语句<pre><code>    echo &quot;Please input a filename&quot;
    read filename
    if [ -f $filename ];then
    echo &quot;this file is a ordinary file.&quot;
    else
    echo &quot;this file is not a ordinary file.&quot;
    fi
</code></pre>
</li>
<li>多分支判断语句<pre><code>    #!/bin/bash

    echo &quot;Please input your math grades&quot;
    read grades

    if [ $grades -gt 100 ] || [ $grades -lt 0 ];then
    echo &quot;Please input the number range in 0 - 100&quot;
    fi

    if [ $grades -ge 90 ] &amp;&amp; [ $grades -le 100 ];then
    echo &quot;Your grade is excellent.&quot;
    elif [ $grades -ge 80 ] &amp;&amp; [ $grades -le 89 ];then
    echo &quot;Your grade is good.&quot;
    elif [ $grades -ge 70 ] &amp;&amp; [ $grades -le 79 ];then
    echo &quot;Your grade is middle.&quot;
    elif [ $grades -ge 60 ] &amp;&amp; [ $grades -le 69 ];then
    echo &quot;Your grade is passing.&quot;
    else
    echo &quot;Your grade is badly.&quot;
    fi
</code></pre>
<pre><code>    #!/bin/bash

    echo &quot;Please input a command&quot;
    read cmd
    case $cmd in
    cpu)    echo &quot;The cpu information is&quot;
            cat  /proc/cpuinfo;;
    mem)    echo &quot;The mem information is&quot;
            cat /proc/meminfo;;
    device) echo &quot;The device information is&quot;
            cat /proc/scsi/device_info;;
    CD-ROM) echo &quot;The CD-ROM information is&quot;
            cat /proc/sys/dev/cdrom/info;;
    *)      echo &quot;Your input command is invalid&quot;
    esac
</code></pre>
</li>
</ul>
</li>
<li>shell 循环语句
<ul>
<li>while<br>
while语句是只要条件为真就执行下面语句。<br>
格式：<br>
while 条件<br>
do<br>
语句<br>
done<pre><code>    #!/bin/bash

    i=$1
    while [ $i -gt 0 ]
    do
    echo $i
    ((i--))
    done
</code></pre>
</li>
<li>until<br>
until语句是只要条件为假就执行下列语句<br>
格式：<br>
until 条件<br>
do<br>
语句<br>
done<pre><code>    #!/bin/bash

    i=$1
    until [ $i -le 0 ]
    do
    echo $i
    ((i--))
    done
</code></pre>
</li>
<li>for<br>
格式：<br>
for 变量 in 列表<br>
do<br>
语句<br>
done<pre><code>    #!/bin/bash
    for i in `seq 2 8` #seq是一个命令，顺序生成一串数字或者字符
    do
    echo $i
    done
</code></pre>
</li>
</ul>
</li>
<li>shell 函数<br>
格式：</li>
</ul>
<pre><code>[function] funcName()
{
语句
[return 返回值]
}
</code></pre>
<p>返回值是可选的，如果没有显示return，则默认返回最后一条语句执行的结果。</p>
<p>shell 函数的返回值只能是整数，一般用来表示函数执行成功与否，0表示成功，其他值表示失败。如果return 其他数据，比如一个字符串，会得到错误提示：&quot;numerical argument required&quot;</p>
<p>如果一定要让函数返回字符串，可以先定义一个变量，用来接收函数的计算结果，脚本在需要的时候访问这个变量来获得函数返回值。</p>
<p>函数参数从 $1 到 $n, $0表示文件名</p>
<pre><code>#!/bin/bash

#打印数字
printNum()
{
   echo $1
}

for i in `seq 2 8` #seq是一个命令，顺序生成一串数字或者字符
do
printNum $i
done
</code></pre>
<p>返回字符串，报错</p>
<pre><code>#!/bin/bash

#打印字符串
printNum()
{
   return &quot;Hello&quot;
}

for i in `seq 2 8` #seq是一个命令，顺序生成一串数字或者字符
do
printNum
done
</code></pre>
<figure data-type="image" tabindex="1"><img src="http://blog.801314.top/post-images/1591697007753.jpg" alt="" loading="lazy"></figure>
<h4 id="脚本命令">脚本命令</h4>
<ul>
<li>diff<br>
比较两个文件的不同</li>
</ul>
<pre><code>[num1,num2]a|c|d[num3,num4]
num1,num2表示在第一个文件的行数
a表示添加：add 
c表示更改：change
d表示删除：delete
num3,num4 表示在第二个文件中的行数
</code></pre>
<pre><code>diff test1 test2
</code></pre>
<ul>
<li>cut<br>
用于字符串截取</li>
</ul>
<pre><code>cut -d              指定分隔符
cut -f 1,7|1-7     指定截取的列
cut -c 1,4|1-4     指定截取的字符位置
</code></pre>
<ul>
<li>sort<br>
用于字符排列</li>
</ul>
<pre><code>sort -n       纯数字排列
sort -r       倒序
sort -u       去掉重复数字
sort -o       输出到指定文件中
sort -t       指定分隔符
sort -k       指定排序的列
</code></pre>
<ul>
<li>uniq<br>
对重复字符做相应的处理，配合sort用<br>
注意：只能是相邻行生效，非相邻行无效，所有需要先sort，然后在uniq</li>
</ul>
<pre><code>uniq       对重复字符做相应的处理
uniq -u    显示唯一的行
uniq -d    显示重复的行
uniq -c    每行显示一次并统计重复次数
</code></pre>
<ul>
<li>&amp;&amp; 和 ||<br>
是与非。<br>
&amp;&amp; 用来执行条件成立后的命令<br>
|| 用来执行条件不成立后的命令</li>
</ul>
<pre><code>#!/bin/bash
ping -c1 -w1 $1 &amp;&gt;/dev/null   &amp;&amp; echo $1 is up   || echo $1 is down
</code></pre>
<ul>
<li>test 和 [] 等同<br>
注意：使用[] 的时候必须要每个变量之间要有空格，和左右中括号也要有空格，否则报错。</li>
</ul>
<pre><code>test &quot;$A&quot;=&quot;$B&quot;      等同 [&quot;$A&quot;=&quot;$B&quot;]
[&quot;$A&quot;=&quot;$B&quot;]         表示&quot;$A&quot;=&quot;$B&quot;成立
[&quot;$A&quot;！=&quot;$B&quot;]       表示&quot;$A&quot;=&quot;$B&quot;不成立
[ -z &quot;$A&quot;]          表示$A是否为空
[ -n &quot;$A&quot;]          表示$A是否不为空  
</code></pre>
<p>整形数据比较：</p>
<pre><code>参数：
-eq   等于
-ne   不等于
-le   小于等于
-lt   小于
-ge   大于等于
-gt   大于

[ &quot;$a&quot; = &quot;$b&quot; -o &quot;$a&quot; -lt &quot;50&quot; ] $a是否等于$b，或者$a小于50
[ &quot;$a&quot; = &quot;$b&quot; -a &quot;$a&quot; -lt &quot;50&quot; ] $a是否等于$b，并且$a小于50
-o   表示或者
-a   表示并且
</code></pre>
<pre><code>编辑脚本：vim check_num.sh   判定一个数字是否在0-10之间,脚本后面没数字显示please give me a number！，有数字进行判定在1-10输出yes否则输出no。
#!/bin/bash
[ -z &quot;$1&quot; ] &amp;&amp; {         判定脚本后第一穿字符是否为空
       echo please give me a number !!
       exit  1
}
[ &quot;$1&quot;  -gt &quot;0&quot; -a &quot;$1&quot;  -lt &quot;10&quot; ]    &amp;&amp; echo  yes || echo  no
</code></pre>
<ul>
<li>test命令：判定文件的类型</li>
</ul>
<pre><code>参数:
[ -e &quot;file&quot; ]    文件是否存在
[ -f &quot;file&quot; ]    文件是否为普通文件
[ -L &quot;file&quot; ]    文件时否为连接（软连接）
[ -S &quot;file&quot; ]    文件是否为套接字
[ -b &quot;file&quot; ]    文件是否为快设备
[ -d &quot;file&quot; ]    文件是否为目录
[ -c &quot;file&quot; ]    文件是否为字符设备
ln -S /mnt/file  /mnt/hello    创建链接-s表示软链接，不加-s表示硬链接
</code></pre>
<p>判定文件是什么类型的文件</p>
<pre><code>编写脚本：vim   file.sh    
内容：
#!/bin/bash
[ -z &quot;$1&quot; ] &amp;&amp; {          脚本后是否为空
       echo please give me a filename !!   为空输出please give me a filename !!
       exit 1
}
[ -e $1 ] || {                文件是否存在
    echo $1 is not file       文件不存在
}
[ -L $1 ] &amp;&amp; {                文件是否为连接
    echo $1 is a link file    文件是连接
    exit 1
}
[ -f $1 ] &amp;&amp; {                 文件是否为普通文件
    echo $1 is a common file   文件是普通文件
}
[ -S $1 ] &amp;&amp; {                 文件是否为套接字
   echo $1 is a sock file      文件是套接字
}
</code></pre>
<ul>
<li>tr<br>
字符转换（文本内容）</li>
</ul>
<pre><code>tr 'a-z' 'A-Z'  &lt; /mnt/westos   &gt; /mnt/hello    
将westox内容转化成大写并重定向到/mnt/hello中
</code></pre>
<ul>
<li>find 查找</li>
</ul>
<pre><code>参数：
-type          类型
-size          大小
-perm          权限
-user          拥有着
-group         所有组
-name          名字
-mindepth      最小深度
-maxdepth      最大深度
</code></pre>
<pre><code>find /mnt/ -type l          查找/mnt/的连接的文件
find /mnt/ -group student   查找/mnt/的student组的文件
find  /mnt/ -user root -a  -group student   
查找/mnt/的文件是root用户并且是student组的文件
find  /mnt/ -user root -o  -group student   
查找/mnt/的文件是root用户或者是student组的文件
</code></pre>
<pre><code>find /etc -maxdepth    深度查找
find /etc -maxdepth 1 -name passwd    查找深度位1的文件
find /etc -mindepth 1 -maxdepth 2 -name passwd    
查找最小深度位1最大深度位2的文件
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux -- Find atime/ctime/mtime 探究]]></title>
        <id>http://blog.801314.top/post/linux-find-atimectimemtime-tan-jiu/</id>
        <link href="http://blog.801314.top/post/linux-find-atimectimemtime-tan-jiu/">
        </link>
        <updated>2020-06-09T08:33:24.000Z</updated>
        <content type="html"><![CDATA[<h3 id="find-atimectimemtime-探究">find atime/ctime/mtime 探究</h3>
<ul>
<li>atime，access time，文件被读取或者执行的时间，修改文件不会改变access time。</li>
<li>ctime， change time，文件状态改变的时间，指文件的i节点被修改的时间，如通过chmod修改文件的属性，ctime就会被改变。</li>
<li>mtime：modify time，文件内容被修改的时间。</li>
</ul>
<ol>
<li>可以使用 stat 命令查看文件的 atime，ctime，mtime</li>
<li>也可以使用 ls 查看文件的atime，ctime，mtime<br>
ls -l 查看文件的mtime<br>
ls -lu 或者 ls -l -time=atime 查看文件的atime<br>
ls -lc 或者 ls -l -time=ctime 查看文件的ctime</li>
</ol>
<h3 id="find-mtime-中的参数n">find -mtime 中的参数n</h3>
<p>find . -mtime n 中的n指的是 24（h）* n</p>
<ul>
<li>+n：大于n</li>
<li>-n：小于n</li>
<li>n：等于n</li>
</ul>
<p>最后一次修改发生在n天以内<br>
find . -mtime -n</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SLF4J 作用及其实现原理]]></title>
        <id>http://blog.801314.top/post/slf4j-zuo-yong-ji-qi-shi-xian-yuan-li/</id>
        <link href="http://blog.801314.top/post/slf4j-zuo-yong-ji-qi-shi-xian-yuan-li/">
        </link>
        <updated>2020-06-03T09:19:45.000Z</updated>
        <content type="html"><![CDATA[<p>文章转载：https://www.cnblogs.com/xrq730/p/8619156.html</p>
<h3 id="简单回顾门面模式">简单回顾门面模式</h3>
<p>slf4j 是门面模式的典型应用，全称是 simple Loging Facade For Java, 是一个为Java程序提供日志输出的统一接口，并不是一个具体的实现方案。就好像JDBC一样，只是一种接口规则定义而已。</p>
<p>门面模式，其核心为<strong>外部与一个子系统的通信必须通过一个统一的外观对象进行，使得子系统更易于使用。</strong><br>
<img src="http://blog.801314.top/post-images/1591176389799.jpg" alt="" loading="lazy"><br>
门面模式的核心为Facade，即门面对象，门面对象核心为几个点：</p>
<ul>
<li>知道所有子角色的功能和责任</li>
<li>将客户端发来的请求委派带子系统中，没有实际业务逻辑</li>
<li>不参与子系统内业务逻辑的实现</li>
</ul>
<h3 id="为什么使用slf4j">为什么使用slf4j</h3>
<p>使用slf4j可以对客户端应用解耦。因为我们在代码实现中引入log日志的时候，用的是接口，所以可以实时的根据情况来调换具体的日志实现类。</p>
<p>举个例子：<br>
我们自己的系统使用了 logback 日志系统<br>
我们系统使用了A.jar，A.jar中使用的日志系统为 log4j<br>
我们系统又使用了B.jar，B.jar 中使用的日志系统为 slf4j-simple<br>
这样，我们的系统就不得不同时支持并维护logback，log4j，slf4j-simple 三种日志框架，非常不方便。</p>
<p>解决这个问题的方式就是引入一个适配层，由适配层决定使用哪一种日志系统，而使用端只需要做的事情就是打印日志，而不需要关系如何打印日志，slf4j或者common-logging就是这种适配层。<br>
<strong>slf4j只是一个日志标准，并不是日志系统的具体实现</strong><br>
slf4j只做两件事：</p>
<ul>
<li>提供日志接口，用于写日志的方法</li>
<li>提供获取具体日志对象的方法<br>
slf4j-simple，logback-classic 都是slf4j的具体实现，log4j并不是直接是实现slf4j，但是有专门的一层桥接 slf4j-log4j12 来实现 slf4j。</li>
</ul>
<h3 id="slf4j-应用举例">slf4j 应用举例</h3>
<p>pom.xml</p>
<pre><code>&lt;!-- 原文：五月的仓颉http://www.cnblogs.com/xrq730/p/8619156.html --&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
      &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

      &lt;groupId&gt;org.xrq.log&lt;/groupId&gt;
      &lt;artifactId&gt;log-test&lt;/artifactId&gt;
      &lt;version&gt;1.0.0&lt;/version&gt;
      &lt;packaging&gt;jar&lt;/packaging&gt;

      &lt;name&gt;log-test&lt;/name&gt;
      &lt;url&gt;http://maven.apache.org&lt;/url&gt;

      &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
      &lt;/properties&gt;

      &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
              &lt;artifactId&gt;junit&lt;/artifactId&gt;
              &lt;version&gt;4.11&lt;/version&gt;
              &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
            &lt;version&gt;1.7.25&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;
            &lt;version&gt;1.7.25&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;log4j&lt;/groupId&gt;
            &lt;artifactId&gt;log4j&lt;/artifactId&gt;
            &lt;version&gt;1.2.17&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
            &lt;version&gt;1.7.21&lt;/version&gt;
        &lt;/dependency&gt;
      &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<p>java 代码：</p>
<pre><code>@Test
public void testSlf4j() {
      Logger logger = LoggerFactory.getLogger(Object.class);
      logger.error(&quot;123&quot;);
 }
</code></pre>
<p>接着我们首先把上面pom.xml的第30行~第49行注释掉，即不引入任何slf4j的实现类，运行Test方法，我们看一下控制台的输出为：</p>
<figure data-type="image" tabindex="1"><img src="http://blog.801314.top/post-images/1591177390542.jpg" alt="" loading="lazy"></figure>
<p>看到没有任何日志的输出，这验证了我们的观点：slf4j不提供日志的具体实现，只有slf4j是无法打印日志的。</p>
<p>接着打开logback-classic的注释，运行Test方法，我们看一下控制台的输出为：</p>
<figure data-type="image" tabindex="2"><img src="http://blog.801314.top/post-images/1591177405976.jpg" alt="" loading="lazy"></figure>
<p>看到我们只要引入了一个slf4j的具体实现类，即可使用该日志框架输出日志。</p>
<p>最后做一个测验，我们把所有日志打开，引入logback-classic、slf4j-simple、log4j，运行Test方法，控制台输出为：</p>
<figure data-type="image" tabindex="3"><img src="http://blog.801314.top/post-images/1591177422719.jpg" alt="" loading="lazy"></figure>
<p>和上面的差别是，可以输出日志，但是会输出一些告警日志，提示我们同时引入了多个slf4j的实现，然后选择其中的一个作为我们使用的日志系统。</p>
<p>从例子我们可以得出一个重要的结论，即slf4j的作用：只要所有代码都使用门面对象slf4j，我们就不需要关心其具体实现，最终所有地方使用一种具体实现即可，更换、维护都非常方便。</p>
<h3 id="slf4j实现原理">slf4j实现原理</h3>
<p>上面看了slf4j的示例，下面研究一下slf4j的实现，我们只关注重点代码。</p>
<p>slf4j的用法就是常年不变的一句&quot;Logger logger = LoggerFactory.getLogger(Object.class);&quot;，可见这里就是通过LoggerFactory去拿slf4j提供的一个Logger接口的具体实现而已，LoggerFactory的getLogger的方法实现为：</p>
<pre><code> 1 public static Logger getLogger(Class&lt;?&gt; clazz) {
 2     Logger logger = getLogger(clazz.getName());
 3     if (DETECT_LOGGER_NAME_MISMATCH) {
 4         Class&lt;?&gt; autoComputedCallingClass = Util.getCallingClass();
 5         if (autoComputedCallingClass != null &amp;&amp; nonMatchingClasses(clazz, autoComputedCallingClass)) {
 6             Util.report(String.format(&quot;Detected logger name mismatch. Given name: \&quot;%s\&quot;; computed name: \&quot;%s\&quot;.&quot;, logger.getName(),
 7                             autoComputedCallingClass.getName()));
 8             Util.report(&quot;See &quot; + LOGGER_NAME_MISMATCH_URL + &quot; for an explanation&quot;);
 9         }
10     }
11     return logger;
12 }
</code></pre>
<p>从第2行开始跟代码，一直跟到LoggerFactory的bind()方法：</p>
<pre><code> 1 private final static void bind() {
 2     try {
 3         Set&lt;URL&gt; staticLoggerBinderPathSet = null;
 4         // skip check under android, see also
 5         // http://jira.qos.ch/browse/SLF4J-328
 6         if (!isAndroid()) {
 7             staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet();
 8             reportMultipleBindingAmbiguity(staticLoggerBinderPathSet);
 9         }
10         // the next line does the binding
11         StaticLoggerBinder.getSingleton();
12         INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION;
13         reportActualBinding(staticLoggerBinderPathSet);
14         fixSubstituteLoggers();
15         replayEvents();
16         // release all resources in SUBST_FACTORY
17         SUBST_FACTORY.clear();
18     } catch (NoClassDefFoundError ncde) {
19         String msg = ncde.getMessage();
20         if (messageContainsOrgSlf4jImplStaticLoggerBinder(msg)) {
21             INITIALIZATION_STATE = NOP_FALLBACK_INITIALIZATION;
22             Util.report(&quot;Failed to load class \&quot;org.slf4j.impl.StaticLoggerBinder\&quot;.&quot;);
23             Util.report(&quot;Defaulting to no-operation (NOP) logger implementation&quot;);
24             Util.report(&quot;See &quot; + NO_STATICLOGGERBINDER_URL + &quot; for further details.&quot;);
25         } else {
26             failedBinding(ncde);
27             throw ncde;
28         }
29     } catch (java.lang.NoSuchMethodError nsme) {
30         String msg = nsme.getMessage();
31         if (msg != null &amp;&amp; msg.contains(&quot;org.slf4j.impl.StaticLoggerBinder.getSingleton()&quot;)) {
32             INITIALIZATION_STATE = FAILED_INITIALIZATION;
33             Util.report(&quot;slf4j-api 1.6.x (or later) is incompatible with this binding.&quot;);
34             Util.report(&quot;Your binding is version 1.5.5 or earlier.&quot;);
35             Util.report(&quot;Upgrade your binding to version 1.6.x.&quot;);
36         }
37         throw nsme;
38     } catch (Exception e) {
39         failedBinding(e);
40         throw new IllegalStateException(&quot;Unexpected initialization failure&quot;, e);
41     }
42 }
</code></pre>
<p>这个地方第7行是一个关键，看一下代码：</p>
<pre><code> 1 static Set&lt;URL&gt; findPossibleStaticLoggerBinderPathSet() {
 2     // use Set instead of list in order to deal with bug #138
 3     // LinkedHashSet appropriate here because it preserves insertion order
 4     // during iteration
 5     Set&lt;URL&gt; staticLoggerBinderPathSet = new LinkedHashSet&lt;URL&gt;();
 6     try {
 7         ClassLoader loggerFactoryClassLoader = LoggerFactory.class.getClassLoader();
 8         Enumeration&lt;URL&gt; paths;
 9         if (loggerFactoryClassLoader == null) {
10             paths = ClassLoader.getSystemResources(STATIC_LOGGER_BINDER_PATH);
11         } else {
12             paths = loggerFactoryClassLoader.getResources(STATIC_LOGGER_BINDER_PATH);
13         }
14         while (paths.hasMoreElements()) {
15             URL path = paths.nextElement();
16             staticLoggerBinderPathSet.add(path);
17         }
18     } catch (IOException ioe) {
19         Util.report(&quot;Error getting resources from path&quot;, ioe);
20     }
21     return staticLoggerBinderPathSet;
22 }
</code></pre>
<p>这个地方重点其实就是第12行的代码，getLogger的时候会去classpath下找STATIC_LOGGER_BINDER_PATH，STATIC_LOGGER_BINDER_PATH值为&quot;org/slf4j/impl/StaticLoggerBinder.class&quot;，即所有slf4j的实现，在提供的jar包路径下，一定是有&quot;org/slf4j/impl/StaticLoggerBinder.class&quot;存在的，我们可以看一下：<br>
<img src="http://blog.801314.top/post-images/1591177466848.jpg" alt="" loading="lazy"><br>
我们不能避免在系统中同时引入多个slf4j的实现，所以接收的地方是一个Set。大家应该注意到，上部分在演示同时引入logback、slf4j-simple、log4j的时候会有警告：<br>
<img src="http://blog.801314.top/post-images/1591177481173.jpg" alt="" loading="lazy"><br>
这就是因为有三个&quot;org/slf4j/impl/StaticLoggerBinder.class&quot;存在的原因，此时reportMultipleBindingAmbiguity方法控制台输出语句：</p>
<pre><code>1 private static void reportMultipleBindingAmbiguity(Set&lt;URL&gt; binderPathSet) {
2     if (isAmbiguousStaticLoggerBinderPathSet(binderPathSet)) {
3         Util.report(&quot;Class path contains multiple SLF4J bindings.&quot;);
4         for (URL path : binderPathSet) {
5             Util.report(&quot;Found binding in [&quot; + path + &quot;]&quot;);
6         }
7         Util.report(&quot;See &quot; + MULTIPLE_BINDINGS_URL + &quot; for an explanation.&quot;);
8     }
9 }
</code></pre>
<p>那网友朋友可能会问，同时存在三个&quot;org/slf4j/impl/StaticLoggerBinder.class&quot;怎么办？首先确定的是这不会导致启动报错，其次在这种情况下编译期间，编译器会选择其中一个StaticLoggerBinder.class进行绑定，这个地方sfl4j也在reportActualBinding方法中报告了绑定的是哪个日志框架：</p>
<pre><code>1 private static void reportActualBinding(Set&lt;URL&gt; binderPathSet) {
2     // binderPathSet can be null under Android
3     if (binderPathSet != null &amp;&amp; isAmbiguousStaticLoggerBinderPathSet(binderPathSet)) {
4         Util.report(&quot;Actual binding is of type [&quot; + StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr() + &quot;]&quot;);
5     }
6 }
</code></pre>
<p>对照上面的截图，看最后一行，确实是&quot;Actual binding is of type...&quot;这句。</p>
<p>最后StaticLoggerBinder就比较简单了，不同的StaticLoggerBinder其getLoggerFactory实现不同，拿到ILoggerFactory之后调用一下getLogger即拿到了具体的Logger，可以使用Logger进行日志输出。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[日志框架整理--logback]]></title>
        <id>http://blog.801314.top/post/ri-zhi-kuang-jia-zheng-li-logback/</id>
        <link href="http://blog.801314.top/post/ri-zhi-kuang-jia-zheng-li-logback/">
        </link>
        <updated>2020-06-02T07:37:19.000Z</updated>
        <content type="html"><![CDATA[<p>logback是有log4j 创始人设计的又一个开源日志框架<br>
logback 当前分为三个模块：logbakc-core，logback-classic 和 logback-access</p>
<ul>
<li>logback-core：是其他两个模块的基础模块</li>
<li>logback-classic：是log4j的一个改良版本。此外logback-classic 完整实现SLF4J API，所以可以很方便的更换成其他日志系统，如 log4j 或 JDK14 Logging</li>
<li>logback-access：访问模块与Servlet容器基础，提供通过http访问日志的功能。</li>
</ul>
<p>maven：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
    &lt;version&gt;1.7.7&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
    &lt;artifactId&gt;logback-core&lt;/artifactId&gt;
    &lt;version&gt;1.1.7&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
    &lt;artifactId&gt;logback-access&lt;/artifactId&gt;
    &lt;version&gt;1.1.7&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
    &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
    &lt;version&gt;1.1.7&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>logback, 一个“通用，可靠，快速又灵活的Java日志框架”</p>
<p>在src目录下建立logback.xml<br>
logback查找顺序：</p>
<ol>
<li>首先会试着查找logback.groovy文件</li>
<li>当没有找到时，继续试着查找 logback-test.xml 文件</li>
<li>当没有找到时，继续试着查找 logback.xml 文件</li>
<li>如果仍然没有找到，则使用默认配置（打印到控制台）</li>
</ol>
<h3 id="自定义日志配置">自定义日志配置</h3>
<p>根据不同的日志系统，可以按照如下规则组织配置文件名，就可以被正确加载：<br>
Logback：logback-spring.xml，logback-spring.groovy,logback.xml,logback.groovy<br>
Log4j: log4J-spring.properties, log4j-spring.xml, log4j.properties, log4j.xml<br>
Log4j2: log4j2-spring.xml, log4j2.xml<br>
JDK(Java Util Logging): logging.properties</p>
<p>Spring Boot 官方推荐优先使用带有-spring的文件名作为你的日志配置（如使用logback-spring.xml，而不是logback.xml), 命名为logback-spring.xml 的日志配置文件，spring boot 可以为它添加一些spring boot特有的配置项。<br>
默认的命名规则，并且放在 src/main/resources 下面即可</p>
<p>如果你不想用 logback.xml 作为 logback 配置的名字，application.yml 可以通过 logging.config 属性指定自定义的名字：<br>
<code>logging.config=classpath:logging-config.xml</code><br>
虽然一般并不需要改变配置文件的名字，但是如果你想针对不同运行是profile使用不同的配置，这个功能会很有用。<br>
一般不需要这个属性，而是直接在 logback-spring.xml 中使用 springProfile配置，不需要logging.config 指定不同环境使用不同配置文件。</p>
<p>上代码：</p>
<pre><code>package logback;  
  
import org.slf4j.Logger;  
import org.slf4j.LoggerFactory;  
  
public class LogbackDemo {  
    private static Logger log = LoggerFactory.getLogger(LogbackDemo.class);  
    public static void main(String[] args) {  
        log.trace(&quot;======trace&quot;);  
        log.debug(&quot;======debug&quot;);  
        log.info(&quot;======info&quot;);  
        log.warn(&quot;======warn&quot;);  
        log.error(&quot;======error&quot;);  
           
        String name = &quot;Aub&quot;;  
        String message = &quot;3Q&quot;;  
        String[] fruits = { &quot;apple&quot;, &quot;banana&quot; };  
          
        // logback提供的可以使用变量的打印方式，结果为&quot;Hello,Aub!&quot;  
        log.info(&quot;Hello,{}!&quot;, name);  
          
        // 可以有多个参数,结果为“Hello,Aub! 3Q!”  
        log.info(&quot;Hello,{}!   {}!&quot;, name, message);  
          
        // 可以传入一个数组，结果为&quot;Fruit:  apple,banana&quot;  
        log.info(&quot;Fruit:  {},{}&quot;, fruits);   
    }  
}  
</code></pre>
<h3 id="configuration">configuration</h3>
<ol>
<li>根节点 configuration 包含的属性：</li>
</ol>
<ul>
<li>scan:<br>
此属性设置为true，配置文件如果发生改变，将会被重新加载，默认为true</li>
<li>scanPeriod:<br>
设置监测配置文件是否有修改的时间间隔，如果没有给出事件单位，默认单位是毫秒。当scan为true时，此属性默认生效。默认的时间将为1分钟。</li>
<li>debug：<br>
此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认为false。<br>
例如：</li>
</ul>
<pre><code>&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&gt;  
      &lt;!-- 其他配置省略--&gt;  
&lt;/configuration&gt;  
</code></pre>
<ol start="2">
<li>根节点 configuration 的子节点：</li>
</ol>
<ul>
<li>contextName<br>
每个logger都关联到logger上下文，默认上下文名称为“default”。但可以使用<contextName>设置成其他名字，用于区分不同应用程序的记录。一旦设置，不能修改。可以通过%contextName来打印日志上下文名称，一般来说我们不用这个属性，可有可无.<br>
例如：</li>
</ul>
<pre><code>&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&gt;  
      &lt;contextName&gt;myAppName&lt;/contextName&gt;  
      &lt;!-- 其他配置省略--&gt;  
&lt;/configuration&gt; 
</code></pre>
<ul>
<li>property<br>
用来定义变量值的标签，property 有两个属性，name和value；通过property定义的值会被插入到 logger上下文中。定义变量后，可以使用 ${} l来使用变量。<br>
例如：</li>
</ul>
<pre><code>&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&gt;  
      &lt;property name=&quot;APP_Name&quot; value=&quot;myAppName&quot; /&gt;   
      &lt;contextName&gt;${APP_Name}&lt;/contextName&gt;  
      &lt;!-- 其他配置省略--&gt;  
&lt;!-- 系统日志输出 --&gt;
	&lt;appender name=&quot;file&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
		&lt;file&gt;${APP_Name}/boss.log&lt;/file&gt;
		&lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
			&lt;!-- 按天回滚 daily --&gt;
			&lt;fileNamePattern&gt;${APP_Name}/boss.%d{yyyy-MM-dd}.log&lt;/fileNamePattern&gt;
			&lt;!-- 日志最大的历史 30天 --&gt;
			&lt;maxHistory&gt;60&lt;/maxHistory&gt;
			&lt;!--用来指定日志文件的上限大小，那么到了这个值，就会删除旧的日志--&gt;
			&lt;!--&lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt;--&gt;
		&lt;/rollingPolicy&gt;
		&lt;encoder&gt;
			&lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{80} - %msg%n&lt;/pattern&gt;
		&lt;/encoder&gt;
	&lt;/appender&gt;
&lt;/configuration&gt; 
</code></pre>
<ul>
<li>timestamp<br>
两个属性：
<ul>
<li>key：标识此 timestamp 的名字</li>
<li>datePattern： 设置将当前时间转换为字符串的模式，遵循 java.txt.SimpleDateFormat 的格式。<br>
例如：</li>
</ul>
</li>
</ul>
<pre><code>&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&gt;  
      &lt;timestamp key=&quot;bySecond&quot; datePattern=&quot;yyyyMMdd'T'HHmmss&quot;/&gt;   
      &lt;contextName&gt;${bySecond}&lt;/contextName&gt;  
      &lt;!-- 其他配置省略--&gt;  
&lt;/configuration&gt;
</code></pre>
<ul>
<li>logger<br>
用来设置某一个包或者具体的某一个类的日志打印级别，以及指定 appender.<br>
包含的属性：
<ul>
<li>name：<br>
用来指定受此logger约束的某一个包或者具体的某一个类。</li>
<li>level：<br>
用来设置打印级别，大小写无关：TRACE，DEBUG，INFO，WARN，ERROR，ALL和OFF，还有一个特殊值 INHERITED 或者同义词NULL，代码强制执行上级的级别。<br>
如果未设置此属性，那么当前logger将会继承上级的打印级别。</li>
<li>additivity：<br>
是否向上级logger传递打印信息。默认是true。<br>
logger可以包含零个或多个 appender-ref 元素，标识这个 appender 将会添加到这个 lgger</li>
</ul>
</li>
<li>root<br>
也是logger元素，但是它是根logger。只有一个level属性，因为已经被命名为“root”
<ul>
<li>level<br>
用来设置打印级别，大小写无关，默认是debug<br>
root 可以包含多个 appender-ref 元素，标识这个appender将会添加到这个 logger<br>
例如：</li>
</ul>
</li>
</ul>
<pre><code>package logback;  
  
import org.slf4j.Logger;  
import org.slf4j.LoggerFactory;  
  
public class LogbackDemo {  
    private static Logger log = LoggerFactory.getLogger(LogbackDemo.class);  
    public static void main(String[] args) {  
        log.trace(&quot;======trace&quot;);  
        log.debug(&quot;======debug&quot;);  
        log.info(&quot;======info&quot;);  
        log.warn(&quot;======warn&quot;);  
        log.error(&quot;======error&quot;);  
    }  
}  
</code></pre>
<p>logback.xml 配置文件：</p>
<pre><code>&lt;configuration&gt;   
   &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;   
    &lt;!-- encoder 默认配置为PatternLayoutEncoder --&gt;   
    &lt;encoder&gt;   
      &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;   
    &lt;/encoder&gt;   
  &lt;/appender&gt;   
   
  &lt;!-- logback为java中的包 --&gt;   
  &lt;logger name=&quot;logback&quot;/&gt;   
  &lt;!--logback.LogbackDemo：类的全路径 --&gt;   
  &lt;logger name=&quot;logback.LogbackDemo&quot; level=&quot;INFO&quot; additivity=&quot;false&quot;&gt;  
    &lt;appender-ref ref=&quot;STDOUT&quot;/&gt;  
  &lt;/logger&gt;   
    
  &lt;root level=&quot;ERROR&quot;&gt;             
    &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;   
  &lt;/root&gt;     
&lt;/configuration&gt;  
</code></pre>
<h3 id="appender">appender</h3>
<pre><code>是 configuration的子节点，是负责写日志的组件
有两个必要属性：
* name： 指定appender的名称
* calss：指定appender的全限定名
</code></pre>
<ol>
<li>ConsoleAppender：<br>
把日志添加到控制台，子节点：
<ul>
<li>encoder： 对日照进行格式化</li>
<li>target：字符串 System.out 或者 System.err, 默认System.out<br>
例如：</li>
</ul>
</li>
</ol>
<pre><code>&lt;configuration&gt;  
  
  &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;  
    &lt;encoder&gt;  
      &lt;pattern&gt;%-4relative [%thread] %-5level %logger{35} - %msg %n&lt;/pattern&gt;  
    &lt;/encoder&gt;  
  &lt;/appender&gt;  
  
  &lt;root level=&quot;DEBUG&quot;&gt;  
    &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;  
  &lt;/root&gt;  
&lt;/configuration&gt;  
</code></pre>
<ol start="2">
<li>FileAppender<br>
把日志添加到文件，子节点：
<ul>
<li>file: 被写入的文件名，可以是相对目录，也可以说是绝对目录，如果上级目录不存在会自动创建，没有默认值</li>
<li>append：如果是true，日志被追加到文件结尾，如果是false，清空现存文件，默认是true。</li>
<li>encoder：对记录时间进行格式化</li>
<li>prudent：如果是true，日志会被安全的写入文件，即使其他的FileAppender也在此文件做写入操作，效率低，默认是false。<br>
例如：</li>
</ul>
</li>
</ol>
<pre><code>&lt;configuration&gt;  
  
  &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.FileAppender&quot;&gt;  
    &lt;file&gt;testFile.log&lt;/file&gt;  
    &lt;append&gt;true&lt;/append&gt;  
    &lt;encoder&gt;  
      &lt;pattern&gt;%-4relative [%thread] %-5level %logger{35} - %msg%n&lt;/pattern&gt;  
    &lt;/encoder&gt;  
  &lt;/appender&gt;  
          
  &lt;root level=&quot;DEBUG&quot;&gt;  
    &lt;appender-ref ref=&quot;FILE&quot; /&gt;  
  &lt;/root&gt;  
&lt;/configuration&gt;
</code></pre>
<ol start="3">
<li>
<p>RollingFileAppender:<br>
滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他问题。<br>
子节点：</p>
<ul>
<li>file：被写入的文件名，可以是相对目录，也可以是绝对目录，如果上级目录不存在会自动创建，没有默认值。</li>
<li>append：如果是 true，日志被追加到文件结尾，如果是 false，清空现存文件，默认是true。</li>
<li>encoder：对记录事件进行格式化。</li>
<li>rollingPolicy: 当发生滚动时，决定RollingFileAppender的行为，涉及文件移动和重命名。</li>
<li>triggeringPolicy：告知 RollingFileAppender 何时激活滚动</li>
<li>prudent: 当为true时，不支持FixedWindowRollingPolicy. 支持 TimeBasedRollingPolicy，但是有两个限制：1. 不支持也不允许文件压缩；2：不能设置file属性，必须留空。</li>
</ul>
<p>rollingPolicy：</p>
<ul>
<li>TimeBasedRollingPolicy<br>
最常用的滚动策略，它根据实际来制定滚动策略，既负责滚动，也负责触发滚动。子节点：
<ul>
<li>fileNamePattern<br>
必要节点，包含文件名及%d 转换符。%d 可以包含一个 java.text.SimpleDateFormat制定的时间格式，如&quot; %d{yyyy-MM} 。如果直接使用%d，默认格式是 yyyy-MM-dd。RollingFileAppender 的file子节点可有可无，通过设置file，可以为活动文件和归档文件制定不同位置，当前日志总是极力到file指定的文件（活动文件），活动文件的名字不会改变；如果没设置file，活动文件的名字会根据 fileNamePattern 的值，每隔一段时间改变一次。&quot;/&quot; 或 &quot;&quot;会被当做目录分隔符。</li>
<li>maxHistory<br>
可选节点，控制保留的归档文件的最大数量，超出数量就删除文件。假设设置每个月滚动，且 maxHistory是6，则只保存最近6个月的文件，删除之前的旧文件。注意，删除旧文件，那些为了归档而创建的目录也会被删除。关于保存的时间的单位，是根据时间格式的单位。</li>
</ul>
</li>
<li>FixedWindowRollingPolicy<br>
根据固定窗口算法重命名文件的滚动策略。子节点：
<ul>
<li>minIndex： 窗口索引最小值</li>
<li>maxIndex：窗口索引最大值，当用户指定的窗口过大时，会自动将窗口设置为12</li>
<li>fileNamePattern：必须包含 %i。例如，假设最小值和最大值分别为1和2，命名模式为 mylog%i.log，会产生归档文件mylog1.log 和 mylog2.log。还可以指定文件压缩选项，例如，mylog%i.log.gz 或者 mylog%i.log.zip。</li>
</ul>
</li>
</ul>
<p>triggeringPolicy:<br>
* SizeBasedTriggeringPolicy<br>
查看当前活动文件的大小，如果超过指定大小会告知RollingFileAppender 触发当前活动文件滚动。只有一个节点：<br>
* maxFileSize：活动文件的大小，默认值是10MB</p>
</li>
</ol>
<p>例如：<br>
每天生产一个日志文件，保存30天的日志</p>
<pre><code>&lt;configuration&gt;   
  &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;   
      
    &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;   
      &lt;fileNamePattern&gt;logFile.%d{yyyy-MM-dd}.log&lt;/fileNamePattern&gt;   
      &lt;maxHistory&gt;30&lt;/maxHistory&gt;    
    &lt;/rollingPolicy&gt;   
   
    &lt;encoder&gt;   
      &lt;pattern&gt;%-4relative [%thread] %-5level %logger{35} - %msg%n&lt;/pattern&gt;   
    &lt;/encoder&gt;   
  &lt;/appender&gt;    
   
  &lt;root level=&quot;DEBUG&quot;&gt;   
    &lt;appender-ref ref=&quot;FILE&quot; /&gt;   
  &lt;/root&gt;   
&lt;/configuration&gt;  
</code></pre>
<p>例如：<br>
按照固定窗口模式生产日志文件，当文件大于20MB时，生产新的日志文件。窗口大小1到3，当保存了3个归档文件后，将覆盖最早的日志。</p>
<pre><code>&lt;configuration&gt;   
  &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;   
    &lt;file&gt;test.log&lt;/file&gt;   
   
    &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot;&gt;   
      &lt;fileNamePattern&gt;tests.%i.log.gz&lt;/fileNamePattern&gt;   
      &lt;minIndex&gt;1&lt;/minIndex&gt;   
      &lt;maxIndex&gt;3&lt;/maxIndex&gt;   
    &lt;/rollingPolicy&gt;   
   
    &lt;triggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;&gt;   
      &lt;maxFileSize&gt;20MB&lt;/maxFileSize&gt;   
    &lt;/triggeringPolicy&gt;   
    &lt;encoder&gt;   
      &lt;pattern&gt;%-4relative [%thread] %-5level %logger{35} - %msg%n&lt;/pattern&gt;   
    &lt;/encoder&gt;   
  &lt;/appender&gt;   
           
  &lt;root level=&quot;DEBUG&quot;&gt;   
    &lt;appender-ref ref=&quot;FILE&quot; /&gt;   
  &lt;/root&gt;   
&lt;/configuration&gt;  
</code></pre>
<p>另外，还是SocketAppender，SMTPAppender，DBAppender，SyslogAppender，SiftingAppender，并不常用。</p>
<ul>
<li>encoder<br>
负责两件事，一是把日志信息转换成字节数组，二是把字节数组写入到输出流<br>
目前 PatterLayoutEncoder 是唯一且有用的默认的 encoder，有一个节点pattern，用来设置日志的输入格式。<br>
使用%加转换符的方式，如果要输出%，则必须用 \ 对 % 进行转义。</li>
</ul>
<p>例如：</p>
<pre><code>&lt;encoder&gt;   
   &lt;pattern&gt;%-4relative [%thread] %-5level %logger{35} - %msg%n&lt;/pattern&gt;   
&lt;/encoder
</code></pre>
<ul>
<li>
<p>pattern 里转换符说明：</p>
<ul>
<li>
<p>c {length } /lo {length } /logger {length }	<br>
输出日志的logger名，可有一个整形参数，功能是缩短logger名，设置为0表示只输入logger最右边点符号之后的字符串。 Conversion specifier Logger name Result<br>
%logger	mainPackage.sub.sample.Bar	mainPackage.sub.sample.Bar<br>
%logger{0}	mainPackage.sub.sample.Bar	Bar<br>
%logger{5}	mainPackage.sub.sample.Bar	m.s.s.Bar<br>
%logger{10}	mainPackage.sub.sample.Bar	m.s.s.Bar<br>
%logger{15}	mainPackage.sub.sample.Bar	m.s.sample.Bar<br>
%logger{16}	mainPackage.sub.sample.Bar	m.sub.sample.Bar<br>
%logger{26}	mainPackage.sub.sample.Bar	mainPackage.sub.sample.Bar</p>
</li>
<li>
<p>C {length } /class {length }	<br>
输出执行记录请求的调用者的全限定名。参数与上面的一样。尽量避免使用，除非执行速度不造成任何问题。</p>
</li>
<li>
<p>contextName /cn	<br>
输出上下文名称。</p>
</li>
<li>
<p>d {pattern } /date {pattern }	<br>
输出日志的打印日志，模式语法与java.text.SimpleDateFormat 兼容。 Conversion Pattern Result<br>
%d	2006-10-20 14:06:49,812<br>
%date	2006-10-20 14:06:49,812<br>
%date{ISO8601}	2006-10-20 14:06:49,812<br>
%date{HH:mm:ss.SSS}	14:06:49.812<br>
%date{dd MMM yyyy ;HH:mm:ss.SSS}	20 oct. 2006;14:06:49.812</p>
</li>
<li>
<p>F / file	<br>
输出执行记录请求的java源文件名。尽量避免使用，除非执行速度不造成任何问题。</p>
</li>
<li>
<p>caller{depth}caller{depth, evaluator-1, ... evaluator-n}	<br>
输出生成日志的调用者的位置信息，整数选项表示输出信息深度。<br>
例如， %caller{2}   输出为：</p>
<p>0 [main] DEBUG - logging statement<br>
Caller+0 at mainPackage.sub.sample.Bar.sampleMethodName(Bar.java:22)<br>
Caller+1 at mainPackage.sub.sample.Bar.createLoggingRequest(Bar.java:17)<br>
例如， %caller{3}   输出为：</p>
<p>16 [main] DEBUG - logging statement<br>
Caller+0 at mainPackage.sub.sample.Bar.sampleMethodName(Bar.java:22)<br>
Caller+1 at mainPackage.sub.sample.Bar.createLoggingRequest(Bar.java:17)<br>
Caller+2 at mainPackage.ConfigTester.main(ConfigTester.java:38)</p>
</li>
<li>
<p>L / line	<br>
输出执行日志请求的行号。尽量避免使用，除非执行速度不造成任何问题。</p>
</li>
<li>
<p>m / msg / message	<br>
输出应用程序提供的信息。</p>
</li>
<li>
<p>M / method	<br>
输出执行日志请求的方法名。尽量避免使用，除非执行速度不造成任何问题。</p>
</li>
<li>
<p>n	<br>
输出平台先关的分行符“\n”或者“\r\n”。</p>
</li>
<li>
<p>p / le / level	<br>
输出日志级别。</p>
</li>
<li>
<p>r / relative	<br>
输出从程序启动到创建日志记录的时间，单位是毫秒</p>
</li>
<li>
<p>t / thread	<br>
输出产生日志的线程名。</p>
</li>
<li>
<p>replace(p ){r, t}	<br>
p 为日志内容，r 是正则表达式，将p 中符合r 的内容替换为t 。<br>
例如， &quot;%replace(%msg){'\s', ''}&quot;</p>
</li>
</ul>
</li>
<li>
<p>格式修饰符，与转换符共同使用<br>
可选的格式修饰符位于 % 和 转换符之间，<br>
第一个可选修饰符是左对齐的标志，符号是减号“-”；接着是可选的最小宽度修饰符，用十进制数表示。如果字符小于最小宽度，则左填充或右填充，默认是左填充（即右对齐），填充符是空格。如果字符大于最小宽度，字符永远不会被截断。最大宽度修饰符，符号是点号&quot;.&quot;后面加十进制。如果字符大于最大宽度，则从前面截断。点符号&quot;.&quot;后面加减号“-”再加数字，表示从尾部截断。<br>
例如：%-4relative 表示将输出从程序启动到创建日志记录的时间，进行左对齐，最小宽度为4.</p>
</li>
</ul>
<h3 id="filter">filter</h3>
<p>过滤器，执行一个过滤器会返回枚举值DENY，NEUTRAL，ACCEPT其中之一。</p>
<ul>
<li>返回DENY，日志将立即被抛弃而不再经过其他过滤器</li>
<li>返回NEUTRAL，有序列表中的下个过滤器会接着处理日志</li>
<li>返回ACCEPT，日志会被立即处理，不再经过剩余过滤器</li>
</ul>
<p>过滤器被添加到 Appender中，为Appender添加一个或夺欧冠过滤器后，可以用任意条件对日志进行过滤。Appender有多个过滤器时，安卓配置顺序执行。</p>
<ul>
<li>常用过滤器：
<ol>
<li>LevelFilter：级别过滤器，根据日志级别进行过滤。如果日志级别等于配置级别，过滤器会根据 onMatch 和 onMismatch 接收或拒绝日志。子节点：
<ul>
<li>level：设置过滤级别</li>
<li>onMatch: 用于配置符合过滤条件的操作</li>
<li>onMismatch：用于配置不符合过滤条件的操作<br>
例如：将过滤器的日志级别配置为INFO，所以INFO级别的日志交给appender处理，非INFO级别的日志，被过滤掉。</li>
</ul>
</li>
</ol>
</li>
</ul>
<pre><code>&lt;configuration&gt;   
  &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;   
    &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;   
      &lt;level&gt;INFO&lt;/level&gt;   
      &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;   
      &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;   
    &lt;/filter&gt;   
    &lt;encoder&gt;   
      &lt;pattern&gt;   
        %-4relative [%thread] %-5level %logger{30} - %msg%n   
      &lt;/pattern&gt;   
    &lt;/encoder&gt;   
  &lt;/appender&gt;   
  &lt;root level=&quot;DEBUG&quot;&gt;   
    &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt;   
  &lt;/root&gt;   
&lt;/configuration&gt;  
</code></pre>
<ol start="2">
<li>ThresholdFilter<br>
临界值过滤器，过滤掉低于指定临界值的日志。当日志级别高于或等于临界值时，过滤器返回NEUTRAL；当日志界别低于临界值时，日志会被拒绝。<br>
例如：过滤掉所有低于INFO级别的日志。</li>
</ol>
<pre><code>&lt;configuration&gt;   
  &lt;appender name=&quot;CONSOLE&quot;   
    class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;   
    &lt;!-- 过滤掉 TRACE 和 DEBUG 级别的日志--&gt;   
    &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;   
      &lt;level&gt;INFO&lt;/level&gt;   
    &lt;/filter&gt;   
    &lt;encoder&gt;   
      &lt;pattern&gt;   
        %-4relative [%thread] %-5level %logger{30} - %msg%n   
      &lt;/pattern&gt;   
    &lt;/encoder&gt;   
  &lt;/appender&gt;   
  &lt;root level=&quot;DEBUG&quot;&gt;   
    &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt;   
  &lt;/root&gt;   
&lt;/configuration&gt;  
</code></pre>
<h3 id="多环节日志输出">多环节日志输出</h3>
<p>通过springProfile 标签</p>
<pre><code>&lt;configuration&gt;
    ...
 
    &lt;!-- 测试环境+开发环境. 多个使用逗号隔开. --&gt;
    &lt;springProfile name=&quot;test,dev&quot;&gt;
        &lt;logger name=&quot;com.example.demo.controller&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;
            &lt;appender-ref ref=&quot;consoleLog&quot;/&gt;
        &lt;/logger&gt;
    &lt;/springProfile&gt;
 
    &lt;!-- 生产环境. --&gt;
    &lt;springProfile name=&quot;prod&quot;&gt;
        &lt;logger name=&quot;com.example.demo.controller&quot; level=&quot;INFO&quot; additivity=&quot;false&quot;&gt;
            &lt;appender-ref ref=&quot;consoleLog&quot;/&gt;
        &lt;/logger&gt;
    &lt;/springProfile&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code>application.yml增加环境选择的配置active: dev
 
server:
  port: 9010
 
spring:
  profiles:
    active: dev
  datasource:
    url: jdbc:mysql://localhost:3306/test?characterEncoding=utf8
    username: root
    password: root
 
mybatis:
    type-aliases-package: org.larry.springboot.entity
    mapper-locations: classpath:mapper/**/*.xml
    check-config-location: true
 
active: 【test、dev、prod】，根据 active 的环境，自动采用上面配置的springProfile的 logger 日志
</code></pre>
<h3 id="自定义日志路径applicationxml">自定义日志路径（application.xml）</h3>
<p>application.xml 增加日志相关自定义配置</p>
<pre><code>logback:
  logdir: /Users/inke/dev/log/tomcat/sell
  appname: sell
</code></pre>
<p>在logback-spring.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&gt;
 
    &lt;!--application.yml 传递参数，不能使用logback 自带的&lt;property&gt;标签 --&gt;
    &lt;springProperty scope=&quot;context&quot; name=&quot;appname&quot; source=&quot;logback.appname&quot;/&gt;
    &lt;springProperty scope=&quot;context&quot; name=&quot;logdir&quot; source=&quot;logback.logdir&quot;/&gt;
 
    &lt;contextName&gt;${appname}&lt;/contextName&gt;
 
    &lt;!--输出到控制台 ConsoleAppender--&gt;
    &lt;appender name=&quot;consoleLog&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;!--展示格式 layout--&gt;
        &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;
            &lt;pattern&gt;
                &lt;pattern&gt;%d{HH:mm:ss.SSS} %contextName [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
            &lt;/pattern&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 泛型详解]]></title>
        <id>http://blog.801314.top/post/java-fan-xing-xiang-jie/</id>
        <link href="http://blog.801314.top/post/java-fan-xing-xiang-jie/">
        </link>
        <updated>2020-06-01T07:45:02.000Z</updated>
        <content type="html"><![CDATA[<p>原文：https://www.cnblogs.com/coprince/p/8603492.html</p>
<h2 id="概述">概述</h2>
<p>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是<strong>将类型由原来的具体的类型参数化</strong>，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p>
<p>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p>
<h2 id="举例">举例</h2>
<pre><code>List arrayList = new ArrayList();
arrayList.add(&quot;aaaa&quot;);
arrayList.add(100);

for(int i = 0; i&lt; arrayList.size();i++){
    String item = (String)arrayList.get(i);
    Log.d(&quot;泛型测试&quot;,&quot;item = &quot; + item);
}
</code></pre>
<p>毫无疑问，程序的运行结果会以崩溃结束：<br>
<code>java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</code><br>
ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。</p>
<p>我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。</p>
<pre><code>List&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();
...
//arrayList.add(100); 在编译阶段，编译器就会报错
</code></pre>
<h2 id="3-特性">3. 特性</h2>
<p>泛型只在编译阶段有效。看下面的代码：</p>
<pre><code>List&lt;String&gt; stringArrayList = new ArrayList&lt;String&gt;();
List&lt;Integer&gt; integerArrayList = new ArrayList&lt;Integer&gt;();

Class classStringArrayList = stringArrayList.getClass();
Class classIntegerArrayList = integerArrayList.getClass();

if(classStringArrayList.equals(classIntegerArrayList)){
    Log.d(&quot;泛型测试&quot;,&quot;类型相同&quot;);
}
</code></pre>
<p>输出结果：D/泛型测试: 类型相同。</p>
<p>通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p>
<p>对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</p>
<h2 id="泛型的使用">泛型的使用</h2>
<p>泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法</p>
<h3 id="43-泛型类">4.3 泛型类</h3>
<p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。</p>
<p>泛型类的最基本写法（这么看可能会有点晕，会在下面的例子中详解）：</p>
<pre><code>class 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;{
  private 泛型标识 /*（成员变量类型）*/ var; 
  .....

  }
}
</code></pre>
<p>一个最普通的泛型类：</p>
<pre><code>//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
//在实例化泛型类时，必须指定T的具体类型
public class Generic&lt;T&gt;{ 
    //key这个成员变量的类型为T,T的类型由外部指定  
    private T key;

    public Generic(T key) { //泛型构造方法形参key的类型也为T，T的类型由外部指定
        this.key = key;
    }

    public T getKey(){ //泛型方法getKey的返回值类型为T，T的类型由外部指定
        return key;
    }
}
</code></pre>
<pre><code>//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型
//传入的实参类型需与泛型的类型参数类型相同，即为Integer.
Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456);

//传入的实参类型需与泛型的类型参数类型相同，即为String.
Generic&lt;String&gt; genericString = new Generic&lt;String&gt;(&quot;key_vlaue&quot;);
Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + genericInteger.getKey());
Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + genericString.getKey());
</code></pre>
<pre><code>12-27 09:20:04.432 13063-13063/? D/泛型测试: key is 123456
12-27 09:20:04.432 13063-13063/? D/泛型测试: key is key_vlaue
</code></pre>
<p>定义的泛型类，就一定要传入泛型类型实参么？并不是这样，在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。</p>
<p>看一个例子：</p>
<pre><code>Generic generic = new Generic(&quot;111111&quot;);
Generic generic1 = new Generic(4444);
Generic generic2 = new Generic(55.55);
Generic generic3 = new Generic(false);

Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic.getKey());
Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic1.getKey());
Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic2.getKey());
Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic3.getKey());
</code></pre>
<pre><code>D/泛型测试: key is 111111
D/泛型测试: key is 4444
D/泛型测试: key is 55.55
D/泛型测试: key is false
</code></pre>
<p><strong>注意：</strong></p>
<ul>
<li>泛型的类型参数只能是类类型，不能是简单类型。</li>
<li>不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。<br>
　　if(ex_num instanceof Generic<Number>){ }</li>
</ul>
<h3 id="44-泛型接口">4.4 泛型接口</h3>
<p>泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子：</p>
<pre><code>//定义一个泛型接口
public interface Generator&lt;T&gt; {
    public T next();
}
</code></pre>
<p>当实现泛型接口的类，未传入泛型实参时：</p>
<pre><code>/**
 * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中
 * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;{
 * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot;
 */
class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;{
    @Override
    public T next() {
        return null;
    }
}
</code></pre>
<p>当实现泛型接口的类，传入泛型实参时：</p>
<pre><code>/**
 * 传入泛型实参时：
 * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt;
 * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。
 * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型
 * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。
 */
public class FruitGenerator implements Generator&lt;String&gt; {

    private String[] fruits = new String[]{&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;};

    @Override
    public String next() {
        Random rand = new Random();
        return fruits[rand.nextInt(3)];
    }
}
</code></pre>
<h3 id="45-泛型通配符">4.5 泛型通配符</h3>
<p>我们知道Ingeter是Number的一个子类，同时在特性章节中我们也验证过Generic<Ingeter>与Generic<Number>实际上是相同的一种基本类型。那么问题来了，在使用Generic<Number>作为形参的方法中，能否使用Generic<Ingeter>的实例传入呢？在逻辑上类似于Generic<Number>和Generic<Ingeter>是否可以看成具有父子关系的泛型类型呢？</p>
<p>为了弄清楚这个问题，我们使用Generic<T>这个泛型类继续看下面的例子：</p>
<pre><code>public void showKeyValue1(Generic&lt;Number&gt; obj){
    Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());
}
</code></pre>
<pre><code>Generic&lt;Integer&gt; gInteger = new Generic&lt;Integer&gt;(123);
Generic&lt;Number&gt; gNumber = new Generic&lt;Number&gt;(456);

showKeyValue(gNumber);

// showKeyValue这个方法编译器会为我们报错：Generic&lt;java.lang.Integer&gt; 
// cannot be applied to Generic&lt;java.lang.Number&gt;
// showKeyValue(gInteger);
</code></pre>
<p>通过提示信息我们可以看到Generic<Integer>不能被看作为`Generic<Number>的子类。由此可以看出:同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。</p>
<p>回到上面的例子，如何解决上面的问题？总不能为了定义一个新的方法来处理Generic<Integer>类型的类，这显然与java中的多台理念相违背。因此我们需要一个在逻辑上可以表示同时是Generic<Integer>和Generic<Number>父类的引用类型。由此类型通配符应运而生。</p>
<p>我们可以将上面的方法改一下：</p>
<pre><code>public void showKeyValue1(Generic&lt;?&gt; obj){
    Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());
}
</code></pre>
<p>类型通配符一般是使用？代替具体的类型实参，注意了，此处’？’是类型实参，而不是类型形参 。重要说三遍！此处’？’是类型实参，而不是类型形参 ！ 此处’？’是类型实参，而不是类型形参 ！再直白点的意思就是，此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。</p>
<p>可以解决当具体类型不确定的时候，这个通配符就是 ?  ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。</p>
<h3 id="46-泛型方法">4.6 泛型方法</h3>
<p>在java中,泛型类的定义非常简单，但是泛型方法就比较复杂了。</p>
<p>尤其是我们见到的大多数泛型类中的成员方法也都使用了泛型，有的甚至泛型类中也包含着泛型方法，这样在初学者中非常容易将泛型方法理解错了。<br>
泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型 。</p>
<pre><code>/**
 * 泛型方法的基本介绍
 * @param tClass 传入的泛型实参
 * @return T 返回值为T类型
 * 说明：
 *     1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。
 *     2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。
 *     3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。
 *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。
 */
public &lt;T&gt; T genericMethod(Class&lt;T&gt; tClass)throws InstantiationException ,
  IllegalAccessException{
        T instance = tClass.newInstance();
        return instance;
}
</code></pre>
<p><code>Object obj = genericMethod(Class.forName(&quot;com.test.test&quot;));</code><br>
4.6.1 泛型方法的基本用法`<br>
光看上面的例子有的同学可能依然会非常迷糊，我们再通过一个例子，把我泛型方法再总结一下。</p>
<pre><code>public class GenericTest {
   //这个类是个泛型类，在上面已经介绍过
   public class Generic&lt;T&gt;{     
        private T key;

        public Generic(T key) {
            this.key = key;
        }

        //我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。
        //这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。
        //所以在这个方法中才可以继续使用 T 这个泛型。
        public T getKey(){
            return key;
        }

        /**
         * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息&quot;cannot reslove symbol E&quot;
         * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。
        public E setKey(E key){
             this.key = keu
        }
        */
    }

    /** 
     * 这才是一个真正的泛型方法。
     * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T
     * 这个T可以出现在这个泛型方法的任意位置.
     * 泛型的数量也可以为任意多个 
     *    如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container){
     *        ...
     *        }
     */
    public &lt;T&gt; T showKeyName(Generic&lt;T&gt; container){
        System.out.println(&quot;container key :&quot; + container.getKey());
        //当然这个例子举的不太合适，只是为了说明泛型方法的特性。
        T test = container.getKey();
        return test;
    }

    //这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。
    public void showKeyValue1(Generic&lt;Number&gt; obj){
        Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());
    }

    //这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?
    //同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类
    public void showKeyValue2(Generic&lt;?&gt; obj){
        Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());
    }

     /**
     * 这个方法是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class 'E' &quot;
     * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。
     * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。
    public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container){
        ...
    }  
    */

    /**
     * 这个方法也是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class 'T' &quot;
     * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。
     * 所以这也不是一个正确的泛型方法声明。
    public void showkey(T genericObj){

    }
    */

    public static void main(String[] args) {


    }
}
</code></pre>
<h4 id="462-类中的泛型方法">4.6.2 类中的泛型方法</h4>
<p>当然这并不是泛型方法的全部，泛型方法可以出现杂任何地方和任何场景中使用。但是有一种情况是非常特殊的，当泛型方法出现在泛型类中时，我们再通过一个例子看一下</p>
<pre><code>public class GenericFruit {
    class Fruit{
        @Override
        public String toString() {
            return &quot;fruit&quot;;
        }
    }

    class Apple extends Fruit{
        @Override
        public String toString() {
            return &quot;apple&quot;;
        }
    }

    class Person{
        @Override
        public String toString() {
            return &quot;Person&quot;;
        }
    }

    class GenerateTest&lt;T&gt;{
        public void show_1(T t){
            System.out.println(t.toString());
        }

        //在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。
        //由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。
        public &lt;E&gt; void show_3(E t){
            System.out.println(t.toString());
        }

        //在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。
        public &lt;T&gt; void show_2(T t){
            System.out.println(t.toString());
        }
    }

    public static void main(String[] args) {
        Apple apple = new Apple();
        Person person = new Person();

        GenerateTest&lt;Fruit&gt; generateTest = new GenerateTest&lt;Fruit&gt;();
        //apple是Fruit的子类，所以这里可以
        generateTest.show_1(apple);
        //编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person
        //generateTest.show_1(person);

        //使用这两个方法都可以成功
        generateTest.show_2(apple);
        generateTest.show_2(person);

        //使用这两个方法也都可以成功
        generateTest.show_3(apple);
        generateTest.show_3(person);
    }
}
</code></pre>
<h4 id="463-泛型方法与可变参数">4.6.3 泛型方法与可变参数</h4>
<p>再看一个泛型方法和可变参数的例子：</p>
<pre><code>public &lt;T&gt; void printMsg( T... args){
    for(T t : args){
        Log.d(&quot;泛型测试&quot;,&quot;t is &quot; + t);
    }
}
</code></pre>
<p><code>printMsg(&quot;111&quot;,222,&quot;aaaa&quot;,&quot;2323.4&quot;,55.55);</code></p>
<h4 id="464-静态方法与泛型">4.6.4 静态方法与泛型</h4>
<p>静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。</p>
<p>即：如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 。</p>
<pre><code>public class StaticGenerator&lt;T&gt; {
    ....
    ....
    /**
     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）
     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。
     * 如：public static void show(T t){..},此时编译器会提示错误信息：
          &quot;StaticGenerator cannot be refrenced from static context&quot;
     */
    public static &lt;T&gt; void show(T t){

    }
}
</code></pre>
<h4 id="465-泛型方法总结">4.6.5 泛型方法总结</h4>
<p>泛型方法能使方法独立于类而产生变化，以下是一个基本的指导原则：</p>
<p>无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化，</p>
<p>那么就应该使用泛型方法。另外对于一个static的方法而已，无法访问泛型类型的参数。</p>
<p>所以如果static方法要使用泛型能力，就必须使其成为泛型方法。</p>
<h4 id="466-泛型上下边界">4.6.6 泛型上下边界</h4>
<p>在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。</p>
<p>为泛型添加上边界，即传入的类型实参必须是指定类型的子类型</p>
<pre><code>public void showKeyValue1(Generic&lt;? extends Number&gt; obj){
    Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());
}
</code></pre>
<pre><code>Generic&lt;String&gt; generic1 = new Generic&lt;String&gt;(&quot;11111&quot;);
Generic&lt;Integer&gt; generic2 = new Generic&lt;Integer&gt;(2222);
Generic&lt;Float&gt; generic3 = new Generic&lt;Float&gt;(2.4f);
Generic&lt;Double&gt; generic4 = new Generic&lt;Double&gt;(2.56);
</code></pre>
<pre><code>//这一行代码编译器会提示错误，因为String类型并不是Number类型的子类
//showKeyValue1(generic1);
</code></pre>
<pre><code>showKeyValue1(generic2);
showKeyValue1(generic3);
showKeyValue1(generic4);
</code></pre>
<p>如果我们把泛型类的定义也改一下:</p>
<pre><code>public class Generic&lt;T extends Number&gt;{
    private T key;

    public Generic(T key) {
        this.key = key;
    }

    public T getKey(){
        return key;
    }
}
</code></pre>
<p>//这一行代码也会报错，因为String不是Number的子类<br>
Generic<String> generic1 = new Generic<String>(&quot;11111&quot;);<br>
再来一个泛型方法的例子：</p>
<pre><code>//在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的&lt;T&gt;上添加上下边界，即在泛型声明的时候添加
//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)，编译器会报错：&quot;Unexpected bound&quot;
public &lt;T extends Number&gt; T showKeyName(Generic&lt;T&gt; container){
    System.out.println(&quot;container key :&quot; + container.getKey());
    T test = container.getKey();
    return test;
}
</code></pre>
<p>通过上面的两个例子可以看出：泛型的上下边界添加，必须与泛型的声明在一起 。</p>
<h3 id="47-关于泛型数组要提一下">4.7 关于泛型数组要提一下</h3>
<p>看到了很多文章中都会提起泛型数组，经过查看sun的说明文档，在java中是”不能创建一个确切的泛型类型的数组”的。</p>
<p>也就是说下面的这个例子是不可以的：</p>
<pre><code>List&lt;String&gt;[] ls = new ArrayList&lt;String&gt;[10];  
</code></pre>
<p>而使用通配符创建泛型数组是可以的，如下面这个例子：</p>
<p><code>List&lt;?&gt;[] ls = new ArrayList&lt;?&gt;[10];</code><br>
这样也是可以的：</p>
<p><code>List&lt;String&gt;[] ls = new ArrayList[10];</code><br>
下面使用Sun的一篇文档的一个例子来说明这个问题：</p>
<pre><code>List&lt;String&gt;[] lsa = new List&lt;String&gt;[10]; // Not really allowed.    
Object o = lsa;    
Object[] oa = (Object[]) o;    
List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;();    
li.add(new Integer(3));    
oa[1] = li; // Unsound, but passes run time store check    
String s = lsa[1].get(0); // Run-time error: ClassCastException.
</code></pre>
<p>这种情况下，由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的，所以可以给oa[1]赋上一个ArrayList而不会出现异常，</p>
<p>但是在取出数据的时候却要做一次类型转换，所以就会出现ClassCastException，如果可以进行泛型数组的声明，</p>
<p>上面说的这种情况在编译期将不会出现任何的警告和错误，只有在运行时才会出错。</p>
<p>而对泛型数组的声明进行限制，对于这样的情况，可以在编译期提示代码有类型安全问题，比没有任何提示要强很多。</p>
<p>下面采用通配符的方式是被允许的:数组的类型不可以是类型变量，除非是采用通配符的方式，因为对于通配符的方式，最后取出数据是要做显式的类型转换的。</p>
<pre><code>List&lt;?&gt;[] lsa = new List&lt;?&gt;[10]; // OK, array of unbounded wildcard type.    
Object o = lsa;    
Object[] oa = (Object[]) o;    
List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;();    
li.add(new Integer(3));    
oa[1] = li; // Correct.    
Integer i = (Integer) lsa[1].get(0); // OK 
</code></pre>
<h2 id="5-最后">5. 最后</h2>
<p>本文中的例子主要是为了阐述泛型中的一些思想而简单举出的，并不一定有着实际的可用性。另外，一提到泛型，相信大家用到最多的就是在集合中，其实，在实际的编程过程中，自己可以使用泛型去简化开发，且能很好的保证代码质量。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 设计模式--建造者（Builder）模式]]></title>
        <id>http://blog.801314.top/post/java-she-ji-mo-shi-jian-zao-zhe-buildermo-shi/</id>
        <link href="http://blog.801314.top/post/java-she-ji-mo-shi-jian-zao-zhe-buildermo-shi/">
        </link>
        <updated>2020-06-01T06:32:30.000Z</updated>
        <content type="html"><![CDATA[<p>建造者模式是日常开发中比较常见的设计模式，它的主要作用就是讲复杂事务创建的过程抽象出来，该抽象的不同实现方式，创建出的对象也不同。<br>
通俗地讲，创建一个对象一般都会有一个固定的步骤，这个固定的步骤我们把它抽象出来。</p>
<p>建造者模式分为两种：</p>
<ul>
<li>经典建造者模式</li>
<li>变种建造者模式</li>
</ul>
<h3 id="经典建造者模式">经典建造者模式</h3>
<p>UML类图<br>
<img src="http://blog.801314.top/post-images/1590993459408.jpg" alt="" loading="lazy"><br>
四个角色：</p>
<ul>
<li>Product -- 产品</li>
<li>Builder -- 抽象的步骤</li>
<li>ConcreteBuilder -- Builder具体的实现</li>
<li>Director -- 使用者</li>
</ul>
<p>代码：</p>
<pre><code> public class Computer {
    /*CPU*/
    private String CPU;
    /*内存*/
    private String memory;
    /*硬盘*/
    private String hardDisk;
    /*键盘*/
    private String keyboard;
    /*鼠标*/
    private String mouse;

    public String getCPU() {
        return CPU;
    }

    public void setCPU(String CPU) {
        this.CPU = CPU;
    }

    public String getMemory() {
        return memory;
    }

    public void setMemory(String memory) {
        this.memory = memory;
    }

    public String getHardDisk() {
        return hardDisk;
    }

    public void setHardDisk(String hardDisk) {
        this.hardDisk = hardDisk;
    }

    public String getKeyboard() {
        return keyboard;
    }

    public void setKeyboard(String keyboard) {
        this.keyboard = keyboard;
    }

    public String getMouse() {
        return mouse;
    }

    public void setMouse(String mouse) {
        this.mouse = mouse;
    }

    @Override
    public String toString() {
        return &quot;Computer{&quot; +
                &quot;CPU='&quot; + CPU + '\'' +
                &quot;, memory='&quot; + memory + '\'' +
                &quot;, hardDisk='&quot; + hardDisk + '\'' +
                &quot;, keyboard='&quot; + keyboard + '\'' +
                &quot;, mouse='&quot; + mouse + '\'' +
                '}';
    }
}
</code></pre>
<p>Builder 类:</p>
<pre><code>public interface ComputerConfigBuilder {
    void setCPU();
    void setMemery();
    void setHardDisk();
    void setKeyboard();
    void setMouse();
    Computer getComputer();
}
</code></pre>
<p>具体实现：</p>
<pre><code>public class LowConfigBuilder implements ComputerConfigBuilder {

    private Computer mComputer;

    public LowConfigBuilder(){
        this.mComputer = new Computer();
    }

    @Override
    public void setCPU() {
        mComputer.setCPU(&quot;i5&quot;);
    }

    @Override
    public void setMemery() {
        mComputer.setMemory(&quot;8G&quot;);
    }

    @Override
    public void setHardDisk() {
        mComputer.setHardDisk(&quot;500G&quot;);
    }

    @Override
    public void setKeyboard() {
        mComputer.setKeyboard(&quot;薄膜键盘&quot;);
    }

    @Override
    public void setMouse() {
        mComputer.setMouse(&quot;有线鼠标&quot;);
    }

    @Override
    public Computer getComputer() {
        return mComputer;
    }
}
</code></pre>
<p>Director:</p>
<pre><code>public class Director {
    private ComputerConfigBuilder mBuilder;
    public void setBuilder(ComputerConfigBuilder builder){
        this.mBuilder = builder;
    }
    public void createComputer(){
        mBuilder.setCPU();
        mBuilder.setMemery();
        mBuilder.setHardDisk();
        mBuilder.setKeyboard();
        mBuilder.setMouse();
    }
    public Computer getComputer(){
        return mBuilder.getComputer();
    }
}
</code></pre>
<p>Test:</p>
<pre><code>Director director = new Director();//创建装机人员
director.setBuilder(new LowConfigBuilder()); //告诉装机人员电脑配置，这里为低配版
director.createComputer(); //装机人员开始组装
Computer computer = director.getComputer(); //从装机人员获取组装好的电脑
System.out.print(&quot;电脑配置：&quot; + computer.toString());  //查看电脑配置

director.setBuilder(new HighConfigBuider());
director.createComputer();
Computer computer = director.getComputer();
System.out.print(&quot;电脑配置：&quot; + computer.toString());
</code></pre>
<h3 id="变种builder模式">变种Builder模式</h3>
<p>代码：</p>
<pre><code>public class Person {
    /*名字（必须）*/
    private final String name;
    /*性别（必须）*/
    private final String gender;
    /*年龄（非必须）*/
    private final String age;
    /*鞋子（非必须）*/
    private final String shoes;
    /*衣服（非必须）*/
    private final String clothes;
    /*钱（非必须）*/
    private final String money;
    /*房子（非必须）*/
    private final String house;
    /*汽车（非必须）*/
    private final String car;
    /*职业（非必须）*/
    private final String career;


    private Person(Builder builder) {
        this.name = builder.name;
        this.gender = builder.gender;
        this.age = builder.age;
        this.shoes = builder.shoes;
        this.clothes = builder.clothes;
        this.money = builder.money;
        this.house = builder.house;
        this.car = builder.car;
        this.career = builder.career;
    }

    public static class Builder {
        private final String name;
        private final String gender;
        private String age;
        private String shoes;
        private String clothes;
        private String money;
        private String house;
        private String car;
        private String career;

        public Builder(String name,String gender) {
            this.name = name;
            this.gender = gender;
        }

        public Builder age(String age) {
            this.age = age;
            return this;
        }

        public Builder car(String car) {
            this.car = car;
            return this;
        }

        public Builder shoes(String shoes) {
            this.shoes = shoes;
            return this;
        }

        public Builder clothes(String clothes) {
            this.clothes = clothes;
            return this;
        }

        public Builder money(String money) {
            this.money = money;
            return this;
        }

        public Builder house(String house) {
            this.house = house;
            return this;
        }

        public Builder career(String career) {
            this.career = career;
            return this;
        }

        public Person build(){
            return new Person(this);
        }
    }
</code></pre>
<p>Test:</p>
<pre><code>        Person person = new Person.Builder(&quot;张三&quot;,&quot;男&quot;)
                .age(&quot;12&quot;)
                .money(&quot;1000000&quot;)
                .car(&quot;宝马&quot;)
                .build();
</code></pre>
]]></content>
    </entry>
</feed>